#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
% Very simple template for SODX lab reports. Most common packages are already included.

% Change according your file encoding
\usepackage{url}

%opening
\title{Seminar Report: Opty}
\author{Peter Grman, Leonardo Tonetto}
\date{\today{}}
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package none
\inputencoding utf8
\fontencoding default
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize 11
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 0
\use_mathdots 0
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
maketitle
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
In this seminar we implemented a transaction server using optimistic concurrency
 control 
\begin_inset CommandInset citation
LatexCommand cite
key "kung1981optimistic"

\end_inset

.
 Basically it assumes that multiple transactions can complete without affecting
 each other, and that therefore transactions can proceed without locking
 the data that they affect because it considers 
\emph on
locking
\emph default
 bottlenecks on any system.
 Before committing, each transaction verifies that no other transaction
 has modified its data.
 If the check reveals conflicting modifications, the committing transaction
 rolls back.
\end_layout

\begin_layout Standard
An optimistic concurrency control system can be divided into the following
 actions:
\end_layout

\begin_layout Enumerate
Read/Write operations where the data is read from the storage and will tentative
ly be written on a temporary location.
\end_layout

\begin_layout Enumerate
Validate operation where the data that needs to be modified will be checked
 if other operations are not conflicting and therefore blocking it from
 finalizing.
\end_layout

\begin_layout Enumerate
Commit/Rollback operations where, if the validation succeeded the data is
 updated with the new value on the storage, otherwise the requester will
 rollback the modification and will then decide what to do (e.g.
 try again or just drop it).
\end_layout

\begin_layout Standard
Along with it we also learned a possible implementation of updatable data
 structure in Erlang that can be accessed by concurrent, possibly distributed
 processes.
 All was possible following the guidelines from 
\begin_inset CommandInset citation
LatexCommand cite
key "emdc_sodx5"

\end_inset

.
\end_layout

\begin_layout Section
System overview
\end_layout

\begin_layout Standard

\bar under
Note
\bar default
: the source code for this part is on the 
\emph on
src/
\emph default
 directory that follows this document.
\end_layout

\begin_layout Standard
On this system, basically we have 
\series bold
\emph on
Clients
\series default
\emph default
 that are going to make requests for 
\series bold
\emph on
Entries
\series default
\emph default
 to 
\emph on
read
\emph default
 or 
\emph on
write
\emph default
 them, probably do some work, then 
\emph on
validate
\emph default
 this data and ask for it to be 
\emph on
committed
\emph default
.
 Each 
\series bold
\emph on
Client
\series default
\emph default
 will do all these operations using a 
\series bold
\emph on
Handler
\series default
\emph default
, which will be individually assigned.
 The 
\series bold
\emph on
Handlers
\series default
\emph default
 therefore will cache 
\series bold
\emph on
Entry
\series default
\emph default
 requests and lookup for new ones using the 
\series bold
\emph on
Store
\series default
\emph default
 API.
 They will also validate a set of 
\emph on
reads
\emph default
 and 
\emph on
writes
\emph default
 with a 
\series bold
\emph on
Validator
\series default
\emph default
 whenever a client wants to commit new modifications.
 An 
\series bold
\emph on
Entry
\series default
\emph default
 will receive 
\emph on
read
\emph default
 and 
\emph on
write
\emph default
 requests as well as 
\emph on
check
\emph default
 it, verifying if the value it contains was read from another 
\series bold
\emph on
Client
\series default
\emph default
 after the requester did, invalidating any desired modification.
 A 
\series bold
\emph on
Validator
\series default
\emph default
 will simply receive 
\emph on
validate
\series bold
\emph default
 
\series default
requests where it's going to check if all the 
\emph on
read
\emph default
 operations performed are valid for each 
\series bold
\emph on
Entry
\series default
\emph default
, if so all the write operations are finally sent.
 Whenever a 
\series bold
\emph on
Client
\series default
\emph default
 wants to join the system it's going to send a 
\emph on
open
\emph default
 request to the 
\series bold
\emph on
Server
\series default
\emph default
.
 The 
\series bold
\emph on
Server
\series default
\emph default
 is going to be responsible for creating a tuple with all the exiting 
\series bold
\emph on
Entries
\series default
\emph default
 of the system and the 
\series bold
\emph on
Validator
\series default
\emph default
 module.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename seminar5/SODX_Opty.png
	lyxscale 80
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Messages between elements
\begin_inset CommandInset label
LatexCommand label
name "fig:Messages"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Messages"

\end_inset

 shows an overview of the messages exchanged between the modules of the
 system.
\end_layout

\begin_layout Subsection
Server
\end_layout

\begin_layout Standard
The 
\series bold
\emph on
Server
\series default
\emph default
 module will simply create a tuple of 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Entries
\end_layout

\end_inset

 as 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Store
\end_layout

\end_inset

, create the 
\series bold
\emph on
Validator
\series default
\emph default
 and wait for two messages:
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

{open, Client}
\end_layout

\end_inset

 message sent by a 
\series bold
\emph on
Client
\series default
\emph default
 that wants to join the system, it will respond back with 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

{transaction, Validator, Store}
\end_layout

\end_inset

 so that these values can be used afterwards when creating the 
\series bold
\emph on
Handler
\series default
\emph default
.
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

stop
\end_layout

\end_inset

 message sent by the 
\series bold
\emph on
Opty
\series default
\emph default
 module which controls the execution of this program.
\end_layout

\begin_layout Standard
The final code of this module is like the following:
\end_layout

\begin_layout Standard

\size small
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},language=erlang"
inline false
status open

\begin_layout Plain Layout

\size small
-module(server).
\end_layout

\begin_layout Plain Layout

\size small
-export([start/1]).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
-ifdef(debug_server).
\end_layout

\begin_layout Plain Layout

\size small
-define(DBG(X,Y,Z),io:format("[SERVER_DEBUG] ~w: ~s ~w~n", [X, Y, Z])).
\end_layout

\begin_layout Plain Layout

\size small
-else.
\end_layout

\begin_layout Plain Layout

\size small
-define(DBG(X,Y,Z), true).
\end_layout

\begin_layout Plain Layout

\size small
-endif.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
start(N) ->
\end_layout

\begin_layout Plain Layout

\size small
    spawn(fun() -> init(N) end).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
init(N) ->
\end_layout

\begin_layout Plain Layout

\size small
    ?DBG(server,"Initilizing the server for N",N),
\end_layout

\begin_layout Plain Layout

\size small
    Store = store:new(N),
\end_layout

\begin_layout Plain Layout

\size small
    Validator = validator:start(),
\end_layout

\begin_layout Plain Layout

\size small
    server(Validator, Store).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
server(Validator, Store) ->
\end_layout

\begin_layout Plain Layout

\size small
    receive
\end_layout

\begin_layout Plain Layout

\size small
        {open, Client} ->
\end_layout

\begin_layout Plain Layout

\size small
            ?DBG(server,"Received an open from Client",Client),
\end_layout

\begin_layout Plain Layout

\size small
            Client ! {transaction, Validator, Store},
\end_layout

\begin_layout Plain Layout

\size small
            server(Validator, Store);
\end_layout

\begin_layout Plain Layout

\size small
        stop ->
\end_layout

\begin_layout Plain Layout

\size small
            store:stop(Store)
\end_layout

\begin_layout Plain Layout

\size small
    end.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that the 
\series bold
\emph on
Server
\series default
\emph default
 after creating the 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Store
\end_layout

\end_inset

 and 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Validator
\end_layout

\end_inset

 will only wait for responses from 
\series bold
\emph on
Clients
\series default
\emph default
.
 The optimistic control will be done by the coordination of the work done
 by 
\series bold
\emph on
Handlers
\series default
\emph default
, 
\series bold
\emph on
Validator
\series default
\emph default
 and 
\series bold
\emph on
Entries
\series default
\emph default
.
\end_layout

\begin_layout Subsection
Store
\end_layout

\begin_layout Standard
As already mentioned, 
\series bold
\emph on
Store
\series default
\emph default
 is an API to allow operations with the 
\series bold
\emph on
Entries
\series default
\emph default
 tuple, such as 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

new()
\end_layout

\end_inset

 and 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

lookup()
\end_layout

\end_inset

.
 Please refer to the source code of this module for more information.
 (
\emph on
Nothing was changed from the original version proposed by 
\begin_inset CommandInset citation
LatexCommand cite
key "emdc_sodx5"

\end_inset


\emph default
)
\emph on
.
\end_layout

\begin_layout Subsection
Client
\end_layout

\begin_layout Standard
The 
\series bold
\emph on
Client
\series default
\emph default
 will send the afore mentioned 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

{open, self()}
\end_layout

\end_inset

 message to the 
\series bold
\emph on
Server
\series default
\emph default
 and will wait for the 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

{transaction, Validator, Store}
\end_layout

\end_inset

 message authorizing it to start a new set of transactions.
 It may also receive a 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

stop
\end_layout

\end_inset

 message from the 
\series bold
\emph on
Opty
\series default
\emph default
 module asking it to finish the execution.
 In this last case it will respond back with a 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

{done, self()}
\end_layout

\end_inset

 message to acknowledge that it's done and finished.
\end_layout

\begin_layout Standard
When a new transaction is initialized it will first create a 
\series bold
\emph on
Handler
\series default
\emph default
 that is going to be linked to this 
\series bold
\emph on
Client
\series default
\emph default
 (using 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

spaw_link()
\end_layout

\end_inset

) and will then enter the 
\emph on
do_transactions
\emph default
 state, where while there are 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Updates
\end_layout

\end_inset

 left to be done it will ask it's 
\series bold
\emph on
Handler
\series default
\emph default
 for 
\emph on
read
\emph default
 and 
\emph on
write
\emph default
 operations.
 Once it's done, it will try to 
\emph on
commit
\emph default
 the modifications by send a 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

{commit, Ref}
\end_layout

\end_inset

 to its 
\series bold
\emph on
Handler
\series default
\emph default
.
 The 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Ref
\end_layout

\end_inset

 is used to identify that specific operation and make sure it was confirmed
 or not.
 As shown on the diagram above, the 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

{Ref, ok}
\end_layout

\end_inset

 and 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

{Ref, abort}
\end_layout

\end_inset

 messages confirming if the transaction could be completed will be sent
 by the 
\series bold
\emph on
Validator
\series default
\emph default
 directly to the 
\series bold
\emph on
Client
\series default
\emph default
 making this request.
\end_layout

\begin_layout Standard
While coding the separated 
\series bold
\emph on
Opty
\series default
\emph default
 module to run on multiple machines a bug rose in the code a fix was made.
 While waiting to receive any message outside the 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

open()
\end_layout

\end_inset

 state, if the system stops (action triggered on the 
\series bold
\emph on
Opty
\series default
\emph default
 module) the 
\series bold
\emph on
Clients
\series default
\emph default
 could be held waiting for responses from the 
\series bold
\emph on
Handlers
\series default
\emph default
, that could also be held waiting for messages from the 
\series bold
\emph on
Entries
\series default
\emph default
, that as already mentioned are started and stopped by the 
\series bold
\emph on
Server
\series default
\emph default
 module.
 Finally catching 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

stop
\end_layout

\end_inset

 messages on these parts of the code is necessary.
\end_layout

\begin_layout Standard
The final version of the code is like the following:
\end_layout

\begin_layout Standard

\size small
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},language=erlang"
inline false
status open

\begin_layout Plain Layout

\size small
-module(client).
\end_layout

\begin_layout Plain Layout

\size small
-export([start/4]).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
-ifdef(debug_client).
\end_layout

\begin_layout Plain Layout

\size small
-define(DBG(X,Y,Z), io:format("[CLIENT_DEBUG] ~w: ~s ~w~n", [X, Y, Z])).
\end_layout

\begin_layout Plain Layout

\size small
-else.
\end_layout

\begin_layout Plain Layout

\size small
-define(DBG(X,Y,Z), true).
\end_layout

\begin_layout Plain Layout

\size small
-endif.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
start(Name, Entries, Updates, Server) ->
\end_layout

\begin_layout Plain Layout

\size small
    spawn(fun() -> init(Name, Entries, Updates, Server, 0, 0) end).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
init(Name, Entries, Updates, Server, Total, Ok) ->
\end_layout

\begin_layout Plain Layout

\size small
    ?DBG(Name,"Initilizing Client",self()),
\end_layout

\begin_layout Plain Layout

\size small
    open(Name, Entries, Updates, Server, Total, Ok).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
open(Name, Entries, Updates, Server, Total, Ok) ->
\end_layout

\begin_layout Plain Layout

\size small
    {A1,A2,A3} = now(),
\end_layout

\begin_layout Plain Layout

\size small
    random:seed(A1, A2, A3),
\end_layout

\begin_layout Plain Layout

\size small
    Server ! {open, self()},
\end_layout

\begin_layout Plain Layout

\size small
    receive
\end_layout

\begin_layout Plain Layout

\size small
        {stop, From} ->
\end_layout

\begin_layout Plain Layout

\size small
            io:format("~w: Transactions TOTAL:~w, OK:~w, -> ~w % ~n",
\end_layout

\begin_layout Plain Layout

\size small
                      [Name, Total, Ok, 100*Ok/Total]),
\end_layout

\begin_layout Plain Layout

\size small
            From ! {done, self()},
\end_layout

\begin_layout Plain Layout

\size small
            ok;
\end_layout

\begin_layout Plain Layout

\size small
        {transaction, Validator, Store} ->
\end_layout

\begin_layout Plain Layout

\size small
            ?DBG(Name,"Received a transaction message from the server!",ok),
\end_layout

\begin_layout Plain Layout

\size small
            Handler = handler:start(self(), Validator, Store),
\end_layout

\begin_layout Plain Layout

\size small
            do_transactions(Name, Entries, Updates, Server, Handler,
\end_layout

\begin_layout Plain Layout

\size small
                            Total, Ok, Updates)
\end_layout

\begin_layout Plain Layout

\size small
    end.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
% Commit transaction
\end_layout

\begin_layout Plain Layout

\size small
do_transactions(Name, Entries, Updates, Server, Handler, Total, Ok, 0) ->
\end_layout

\begin_layout Plain Layout

\size small
    %io:format("~w: Commit: TOTAL ~w, OK ~w~n", [Name, Total, Ok]),
\end_layout

\begin_layout Plain Layout

\size small
    %timer:sleep(Name*10),
\end_layout

\begin_layout Plain Layout

\size small
    Ref = make_ref(),
\end_layout

\begin_layout Plain Layout

\size small
    Handler ! {commit, Ref},
\end_layout

\begin_layout Plain Layout

\size small
    Result = receiveCommitValue(Ref),
\end_layout

\begin_layout Plain Layout

\size small
    if
\end_layout

\begin_layout Plain Layout

\size small
        Result == ok ->
\end_layout

\begin_layout Plain Layout

\size small
           open(Name, Entries, Updates, Server, Total+1, Ok+1);
\end_layout

\begin_layout Plain Layout

\size small
        Result == stop ->
\end_layout

\begin_layout Plain Layout

\size small
            close(Name, Total, Ok);
\end_layout

\begin_layout Plain Layout

\size small
        true ->
\end_layout

\begin_layout Plain Layout

\size small
            open(Name, Entries, Updates, Server, Total+1, Ok)
\end_layout

\begin_layout Plain Layout

\size small
    end;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
% Reads and Writes
\end_layout

\begin_layout Plain Layout

\size small
do_transactions(Name, Entries, Updates, Server, Handler, Total, Ok, N) ->
\end_layout

\begin_layout Plain Layout

\size small
    %io:format("~w: R/W: TOTAL ~w, OK ~w, N ~w~n",[Name, Total, Ok, N]),
\end_layout

\begin_layout Plain Layout

\size small
    Ref = make_ref(),
\end_layout

\begin_layout Plain Layout

\size small
    Num = random:uniform(Entries),
\end_layout

\begin_layout Plain Layout

\size small
    Handler ! {read, Ref, Num},
\end_layout

\begin_layout Plain Layout

\size small
    Value = receiveValue(Ref),
\end_layout

\begin_layout Plain Layout

\size small
    if
\end_layout

\begin_layout Plain Layout

\size small
        Value == stop ->
\end_layout

\begin_layout Plain Layout

\size small
            close(Name, Total, Ok);
\end_layout

\begin_layout Plain Layout

\size small
        true ->
\end_layout

\begin_layout Plain Layout

\size small
            Handler ! {write, Num, Value+1},
\end_layout

\begin_layout Plain Layout

\size small
            do_transactions(Name, Entries, Updates, Server, Handler, Total,
 Ok, N-1)
\end_layout

\begin_layout Plain Layout

\size small
    end.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
receiveCommitValue(Ref) ->
\end_layout

\begin_layout Plain Layout

\size small
    ?DBG(self(),"Waiting to receive commits",waiting),
\end_layout

\begin_layout Plain Layout

\size small
    receive
\end_layout

\begin_layout Plain Layout

\size small
        {Ref,Value} ->
\end_layout

\begin_layout Plain Layout

\size small
            ?DBG(self(),"Got the commit",ok),
\end_layout

\begin_layout Plain Layout

\size small
            Value;
\end_layout

\begin_layout Plain Layout

\size small
        {stop, From} ->
\end_layout

\begin_layout Plain Layout

\size small
            ?DBG(self(),"Got a stop from Opty",stop),
\end_layout

\begin_layout Plain Layout

\size small
            From ! {done, self()},
\end_layout

\begin_layout Plain Layout

\size small
            stop
\end_layout

\begin_layout Plain Layout

\size small
    end.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
receiveValue(Ref) ->
\end_layout

\begin_layout Plain Layout

\size small
    ?DBG(self(),"Waiting to receive the Value",waiting),
\end_layout

\begin_layout Plain Layout

\size small
    receive
\end_layout

\begin_layout Plain Layout

\size small
        {value,Ref,Value} ->
\end_layout

\begin_layout Plain Layout

\size small
            ?DBG(self(),"Got the value",ok),
\end_layout

\begin_layout Plain Layout

\size small
            Value;
\end_layout

\begin_layout Plain Layout

\size small
        {stop, From} ->
\end_layout

\begin_layout Plain Layout

\size small
            ?DBG(self(),"Got a stop from Opty",stop),
\end_layout

\begin_layout Plain Layout

\size small
            From ! {done, self()},
\end_layout

\begin_layout Plain Layout

\size small
            stop
\end_layout

\begin_layout Plain Layout

\size small
    end.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
close(Name, Total, Ok) ->
\end_layout

\begin_layout Plain Layout

\size small
    io:format("~w: Transactions TOTAL:~w, OK:~w, -> ~w % ~n",
\end_layout

\begin_layout Plain Layout

\size small
              [Name, Total, Ok, 100*Ok/Total]),
\end_layout

\begin_layout Plain Layout

\size small
    ok.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Also a 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

close()
\end_layout

\end_inset

 function was added to be used when a 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

stop
\end_layout

\end_inset

 is catch outside the 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

open()
\end_layout

\end_inset

 state.
\end_layout

\begin_layout Subsection
Handler
\end_layout

\begin_layout Standard
Each 
\series bold
\emph on
Handler
\series default
\emph default
 is going to be created for every new set of transactions a 
\series bold
\emph on
Client
\series default
\emph default
 is going to perform.
 It will be linked to the 
\series bold
\emph on
Client
\series default
\emph default
 process by the 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

spawn_link()
\end_layout

\end_inset

 function call and will be initialized with the 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Validator
\end_layout

\end_inset

 and 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Store
\end_layout

\end_inset

 elements that the 
\series bold
\emph on
Client
\series default
\emph default
 received from the 
\series bold
\emph on
Server
\series default
\emph default
 once it was starting its execution.
\end_layout

\begin_layout Standard
The 
\series bold
\emph on
Handler
\series default
\emph default
 will then wait for 5 possible messages:
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

{read, Ref, N}
\end_layout

\end_inset

 message from its 
\series bold
\emph on
Client
\series default
\emph default
 trying to read a value from the 
\series bold
\emph on
Entry
\series default
\emph default
 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

N
\end_layout

\end_inset

.
 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Ref
\end_layout

\end_inset

 will contain unique reference number to sing this 
\emph on
read
\emph default
 operation.
 This reference number is going to be used later when the 
\series bold
\emph on
Client
\series default
\emph default
 will try to commit its modifications.
 If the 
\series bold
\emph on
Client
\series default
\emph default
 is requesting an 
\series bold
\emph on
Entry
\series default
\emph default
 for the first time the 
\series bold
\emph on
Handler
\series default
\emph default
 will 
\emph on
lookup
\emph default
 for that one on its 
\series bold
\emph on
Store
\series default
\emph default
 tuple and will request that 
\series bold
\emph on
Entry
\series default
\emph default
 for the value it contains\SpecialChar \@.
 Otherwise, for already requested values the 
\series bold
\emph on
Handler
\series default
\emph default
 will simply send the cached value it already had stored.
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

{Ref, Entry, Value, Time}
\end_layout

\end_inset

 message sent by the 
\series bold
\emph on
Entry
\series default
\emph default
 it requested the value for when doing it for the first time.
 Now having the value it's send to the 
\series bold
\emph on
Client
\series default
\emph default
.
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

{write, N, Value}
\end_layout

\end_inset

 message from the 
\series bold
\emph on
Client
\series default
\emph default
, asking it to modify the value of a certain 
\series bold
\emph on
Entry
\series default
\emph default
.
 This 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Value
\end_layout

\end_inset

 is not gonna be immediately updated on the corresponding 
\series bold
\emph on
Entry
\series default
\emph default
, it will be kept in a list by the 
\series bold
\emph on
Handler
\series default
\emph default
 to be committed later on when the 
\series bold
\emph on
Client
\series default
\emph default
 asks for it.
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

{commit, Ref}
\end_layout

\end_inset

 message from a 
\series bold
\emph on
Client
\series default
\emph default
, asking for the modifications to be committed and the values updated on
 the corresponding 
\series bold
\emph on
Entries
\series default
\emph default
.
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

abort
\end_layout

\end_inset

 message.
 (
\emph on
Apparently not sent by anyone)
\end_layout

\begin_layout Standard
The final version of the code is like the following:
\end_layout

\begin_layout Standard

\size small
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},language=erlang"
inline false
status open

\begin_layout Plain Layout

\size small
-module(handler).
\end_layout

\begin_layout Plain Layout

\size small
-export([start/3]).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
-ifdef(debug_handler).
\end_layout

\begin_layout Plain Layout

\size small
-define(DBG(X,Y,Z), io:format("[HANDLER_DEBUG] ~w: ~s ~w~n", [X, Y, Z])).
\end_layout

\begin_layout Plain Layout

\size small
-else.
\end_layout

\begin_layout Plain Layout

\size small
-define(DBG(X,Y,Z), true).
\end_layout

\begin_layout Plain Layout

\size small
-endif.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
start(Client, Validator, Store) ->
\end_layout

\begin_layout Plain Layout

\size small
    spawn_link(fun() -> init(Client, Validator, Store) end).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
init(Client, Validator, Store) ->
\end_layout

\begin_layout Plain Layout

\size small
    handler(Client, Validator, Store, [], []).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
handler(Client, Validator, Store, Reads, Writes) ->
\end_layout

\begin_layout Plain Layout

\size small
    ?DBG(Client,"Waiting on Handler state",waiting),
\end_layout

\begin_layout Plain Layout

\size small
    receive
\end_layout

\begin_layout Plain Layout

\size small
        {read, Ref, N} ->
\end_layout

\begin_layout Plain Layout

\size small
            case lists:keysearch(N, 1, Writes) of
\end_layout

\begin_layout Plain Layout

\size small
                {value, {N, _, Value}} ->
\end_layout

\begin_layout Plain Layout

\size small
                    ?DBG(Client,"Existing read entry",Value),
\end_layout

\begin_layout Plain Layout

\size small
                    Client ! {value, Ref, Value},
\end_layout

\begin_layout Plain Layout

\size small
                    handler(Client, Validator, Store, Reads, Writes);
\end_layout

\begin_layout Plain Layout

\size small
                false ->
\end_layout

\begin_layout Plain Layout

\size small
                    ?DBG(Client,"New entry requested",N),
\end_layout

\begin_layout Plain Layout

\size small
                    Entry = store:lookup(N, Store),
\end_layout

\begin_layout Plain Layout

\size small
                    Entry ! {read, Ref, self()},
\end_layout

\begin_layout Plain Layout

\size small
                    handler(Client, Validator, Store, Reads, Writes)
\end_layout

\begin_layout Plain Layout

\size small
            end;
\end_layout

\begin_layout Plain Layout

\size small
        {Ref, Entry, Value, Time} ->
\end_layout

\begin_layout Plain Layout

\size small
            ?DBG(Client,"Received the read value from the Entry:",Value),
\end_layout

\begin_layout Plain Layout

\size small
            Client ! {value, Ref, Value},
\end_layout

\begin_layout Plain Layout

\size small
            handler(Client, Validator, Store, [{Entry, Time}|Reads], Writes);
\end_layout

\begin_layout Plain Layout

\size small
        {write, N, Value} ->
\end_layout

\begin_layout Plain Layout

\size small
            ?DBG(Client,"write received for entry N",N),
\end_layout

\begin_layout Plain Layout

\size small
            Entry = store:lookup(N, Store),
\end_layout

\begin_layout Plain Layout

\size small
            Added = lists:keystore(N, 1, Writes,{N, Entry, Value}),
\end_layout

\begin_layout Plain Layout

\size small
            handler(Client, Validator, Store, Reads, Added);
\end_layout

\begin_layout Plain Layout

\size small
        {commit, Ref} ->
\end_layout

\begin_layout Plain Layout

\size small
            ?DBG(Client,"Sending a validate to commit the transactions",Ref),
\end_layout

\begin_layout Plain Layout

\size small
            Validator ! {validate, Ref, Reads, Writes, Client};
\end_layout

\begin_layout Plain Layout

\size small
        abort ->
\end_layout

\begin_layout Plain Layout

\size small
            ?DBG(Client,"abort received!",ok),
\end_layout

\begin_layout Plain Layout

\size small
            ok
\end_layout

\begin_layout Plain Layout

\size small
    end.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Validator
\end_layout

\begin_layout Standard
The 
\series bold
\emph on
Validator
\series default
\emph default
 will be 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

spawn_link()
\end_layout

\end_inset

'ed to the 
\series bold
\emph on
Server
\series default
\emph default
 and will simply wait for 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

{validate, Ref, Reads, Writes, Client}
\end_layout

\end_inset

 messages from 
\series bold
\emph on
Handlers
\series default
\emph default
.
 Once it receives one of these messages it will first check if all the 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Reads
\end_layout

\end_inset

 don't conflict with any other 
\emph on
read
\emph default
 performed on each 
\series bold
\emph on
Entry
\series default
\emph default
 affected by these operations by sending 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

{check, Tag, Time, Self}
\end_layout

\end_inset

 messages and waiting for 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

{Tag, ok}
\end_layout

\end_inset

 confirming the consistent state of these operations.
 Otherwise it will receive a 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

{Tag, abort}
\end_layout

\end_inset

 for any of the 
\series bold
\emph on
Entries
\series default
\emph default
 and the whole validation is aborted and the requesting 
\series bold
\emph on
Client
\series default
\emph default
 will receive a 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

{Ref, abort}
\end_layout

\end_inset

 message from it.
\end_layout

\begin_layout Standard
If it succeeds, then all the write operations are sent to the 
\series bold
\emph on
Entries
\series default
\emph default
 and the 
\series bold
\emph on
Client
\series default
\emph default
 will receive a 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

{Ref, ok}
\end_layout

\end_inset

 message from the 
\series bold
\emph on
Validator
\series default
\emph default
.
 The final version of this code is like the following:
\end_layout

\begin_layout Standard

\size small
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},language=erlang"
inline false
status open

\begin_layout Plain Layout

-module(validator).
\end_layout

\begin_layout Plain Layout

-export([start/0]).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-ifdef(debug).
\end_layout

\begin_layout Plain Layout

-define(DBG(X,Y,Z), io:format("[VALIDATOR_DEBUG] ~w: ~s ~w~n", [X, Y, Z])).
\end_layout

\begin_layout Plain Layout

-else.
\end_layout

\begin_layout Plain Layout

-define(DBG(X,Y,Z), true).
\end_layout

\begin_layout Plain Layout

-endif.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

start() ->
\end_layout

\begin_layout Plain Layout

    spawn_link(fun() -> init() end).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

init()->
\end_layout

\begin_layout Plain Layout

    ?DBG(validator,"Initializing validator",ok),
\end_layout

\begin_layout Plain Layout

    validator().
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

validator() ->
\end_layout

\begin_layout Plain Layout

    receive
\end_layout

\begin_layout Plain Layout

        {validate, Ref, Reads, Writes, Client} ->
\end_layout

\begin_layout Plain Layout

            ?DBG(validator,"Received a validate from client",Client),
\end_layout

\begin_layout Plain Layout

            case validate(Reads) of
\end_layout

\begin_layout Plain Layout

                ok ->
\end_layout

\begin_layout Plain Layout

                    update(Writes),
\end_layout

\begin_layout Plain Layout

                    Client ! {Ref, ok};
\end_layout

\begin_layout Plain Layout

                abort ->
\end_layout

\begin_layout Plain Layout

                    Client ! {Ref, abort}
\end_layout

\begin_layout Plain Layout

            end,
\end_layout

\begin_layout Plain Layout

            validator();
\end_layout

\begin_layout Plain Layout

        _Old ->
\end_layout

\begin_layout Plain Layout

            validator()
\end_layout

\begin_layout Plain Layout

    end.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

update(Writes) ->
\end_layout

\begin_layout Plain Layout

    ?DBG(validator,"Commiting writes!",ok),
\end_layout

\begin_layout Plain Layout

    lists:map(fun({_, Entry, Value}) ->
\end_layout

\begin_layout Plain Layout

                      Entry ! {write, Value}
\end_layout

\begin_layout Plain Layout

              end,
\end_layout

\begin_layout Plain Layout

              Writes).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

validate(Reads) ->
\end_layout

\begin_layout Plain Layout

    {N, Tag} = send_checks(Reads),
\end_layout

\begin_layout Plain Layout

    check_reads(N, Tag).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

send_checks(Reads) ->
\end_layout

\begin_layout Plain Layout

    Tag = make_ref(),
\end_layout

\begin_layout Plain Layout

    Self = self(),
\end_layout

\begin_layout Plain Layout

    N = length(Reads),
\end_layout

\begin_layout Plain Layout

    lists:map(fun({Entry, Time}) ->
\end_layout

\begin_layout Plain Layout

                      Entry ! {check, Tag, Time, Self}
\end_layout

\begin_layout Plain Layout

              end,
\end_layout

\begin_layout Plain Layout

              Reads),
\end_layout

\begin_layout Plain Layout

    {N, Tag}.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

check_reads(0, Tag) ->
\end_layout

\begin_layout Plain Layout

    ?DBG(validator,"All reads were ok for Tag",Tag),
\end_layout

\begin_layout Plain Layout

    ok;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

check_reads(N, Tag) ->
\end_layout

\begin_layout Plain Layout

    receive
\end_layout

\begin_layout Plain Layout

        {Tag, ok} ->
\end_layout

\begin_layout Plain Layout

            check_reads(N-1, Tag);
\end_layout

\begin_layout Plain Layout

        {Tag, abort} ->
\end_layout

\begin_layout Plain Layout

            ?DBG(validator,"Conflicting reads for Tag",Tag),
\end_layout

\begin_layout Plain Layout

            abort
\end_layout

\begin_layout Plain Layout

    end.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Entry
\end_layout

\begin_layout Standard
An 
\series bold
\emph on
Entry
\series default
\emph default
 is a storage unit that will store a 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Value
\end_layout

\end_inset

, and the 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Time
\end_layout

\end_inset

 of the last 
\emph on
read
\emph default
 operation, which is in fact a unique reference number (not actually a time
 value).
 This element will wait for 4 possible messages:
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

{read, Ref, From}
\end_layout

\end_inset

 message from a 
\series bold
\emph on
Handler
\series default
\emph default
 which is answered back with the 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Value
\end_layout

\end_inset

 and the 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Time
\end_layout

\end_inset

 of the last write operation (or when it was initialized).
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

{write, New}
\end_layout

\end_inset

 message from a 
\series bold
\emph on
Handler
\series default
\emph default
, updating its current 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Value
\end_layout

\end_inset

 and generating a new reference number as 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Time
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

{check, Ref, Time, From}
\end_layout

\end_inset

 message from a 
\series bold
\emph on
Handler
\series default
\emph default
 that will verify if the desired commit operation from a 
\series bold
\emph on
Client
\series default
\emph default
 can be performed.
 It's done by comparing the 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Time
\end_layout

\end_inset

 of the remote data with the local one (in the 
\series bold
\emph on
Entry
\series default
\emph default
).
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

stop
\end_layout

\end_inset

 message from the 
\series bold
\emph on
Server
\series default
\emph default
, using the 
\series bold
\emph on
Store
\series default
\emph default
 API function 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

store:stop()
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Another modification was done in our version to use pattern matching instead
 of 
\series bold
\emph on
if
\series default
\emph default
 expressions, that looks more natural when programming a functional language.
\end_layout

\begin_layout Standard
The final version of this code is like the following:
\end_layout

\begin_layout Standard

\size small
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},language=erlang"
inline false
status open

\begin_layout Plain Layout

\size small
-module(entry).
\end_layout

\begin_layout Plain Layout

\size small
-export([new/1]).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
-ifdef(debug).
\end_layout

\begin_layout Plain Layout

\size small
-define(DBG(X,Y,Z), io:format("[ENTRY_DEBUG] ~w: ~s ~w~n", [X, Y, Z])).
 
\end_layout

\begin_layout Plain Layout

\size small
-else.
\end_layout

\begin_layout Plain Layout

\size small
-define(DBG(X,Y,Z), true).
\end_layout

\begin_layout Plain Layout

\size small
-endif.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
new(Value) ->
\end_layout

\begin_layout Plain Layout

\size small
    spawn_link(fun() -> init(Value) end).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
init(Value) ->
\end_layout

\begin_layout Plain Layout

\size small
    entry(Value, make_ref()).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
entry(Value, Time) ->
\end_layout

\begin_layout Plain Layout

\size small
    receive
\end_layout

\begin_layout Plain Layout

\size small
        {read, Ref, From} ->
\end_layout

\begin_layout Plain Layout

\size small
            ?DBG(self(),"Received a read with Ref",Ref),
\end_layout

\begin_layout Plain Layout

\size small
            From ! {Ref, self(), Value, Time},
\end_layout

\begin_layout Plain Layout

\size small
            entry(Value, Time);
\end_layout

\begin_layout Plain Layout

\size small
        {write, New} ->
\end_layout

\begin_layout Plain Layout

\size small
            ?DBG(self(),"Received a write with Value",New),
\end_layout

\begin_layout Plain Layout

\size small
            entry(New, make_ref());
\end_layout

\begin_layout Plain Layout

\size small
        {check, Ref, Time, From} -> %% use pattern matching is more natural
\end_layout

\begin_layout Plain Layout

\size small
            ?DBG(self(),"[OK] Received a check for {Ref,Time}",{Ref,Time}),
\end_layout

\begin_layout Plain Layout

\size small
            From ! {Ref, ok},
\end_layout

\begin_layout Plain Layout

\size small
            entry(Value, Time);
\end_layout

\begin_layout Plain Layout

\size small
        {check, Ref, _Readtime, From} -> %% Readtime is not used, we discard
 it
\end_layout

\begin_layout Plain Layout

\size small
            ?DBG(self(),"[Abort] Received a check for {Ref,Time}",{Ref,Time}),
\end_layout

\begin_layout Plain Layout

\size small
            From ! {Ref, abort},
\end_layout

\begin_layout Plain Layout

\size small
            entry(Value, Time);
\end_layout

\begin_layout Plain Layout

\size small
        stop ->
\end_layout

\begin_layout Plain Layout

\size small
            ?DBG(self(),"Stop",[]),
\end_layout

\begin_layout Plain Layout

\size small
            ok
\end_layout

\begin_layout Plain Layout

\size small
    end.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Opty
\end_layout

\begin_layout Standard
This module simply executes the code, creating the 
\series bold
\emph on
Server
\series default
\emph default
 and the requested number of 
\series bold
\emph on
Clients
\series default
\emph default
 that will have access to a certain number of 
\series bold
\emph on
Entries
\series default
\emph default
, will perform a desired number of 
\series bold
\emph on
Updates
\series default
\emph default
 per transaction and the whole system will run for a desired 
\series bold
\emph on
Time
\series default
\emph default
.
 Please refer to the source code for implementation information.
 (
\emph on
Nothing was changed from what was proposed by 
\begin_inset CommandInset citation
LatexCommand cite
key "emdc_sodx5"

\end_inset


\emph default
).
\end_layout

\begin_layout Section
Evaluation
\end_layout

\begin_layout Standard
After concluding the implementation of this code we can run it with different
 number of parameters and as 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Opty-executing"

\end_inset

 shows, the system works as expected without the use of any locking.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename seminar5/opty_simple.png
	lyxscale 50
	scale 45

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Opty executing
\begin_inset CommandInset label
LatexCommand label
name "fig:Opty-executing"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Further discussion with multiple numbers of 
\series bold
\emph on
Entries
\series default
\emph default
, different duration of each transaction on the 
\series bold
\emph on
Client
\series default
\emph default
, a limited view of the total number of 
\series bold
\emph on
Entries
\series default
\emph default
 by each 
\series bold
\emph on
Client
\series default
\emph default
 will be discussed later on this document.
\end_layout

\begin_layout Standard
But also, executions of the system with a high number of 
\series bold
\emph on
Client
\series default
\emph default
 and 
\series bold
\emph on
Updates
\series default
\emph default
, vary the number of possible total transactions concluded since conflicting
 commits will be much more frequent.
\end_layout

\begin_layout Section
Open questions
\end_layout

\begin_layout Standard

\bar under
Note
\bar default
: the source code for this section is in both 
\emph on
src/
\emph default
 and 
\emph on
srcbis/
\emph default
 directories that follow this document.
\end_layout

\begin_layout Standard
For this section, to automate the requested tests we modified heavily the
 source code of the system.
 We introduced the 
\series bold
\emph on
Statistic
\series default
\emph default
 module.
 This will be a thread that will collect the execution results from the
 existing 
\series bold
\emph on
Clients
\series default
\emph default
, calculate the average of their values for each round of execution and
 present it at the end.
 It will wait for 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

{statistic, Round, Total, OK}
\end_layout

\end_inset

 messages that for each 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Round
\end_layout

\end_inset

 it will calculate the average of 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Total
\end_layout

\end_inset

 (total number of operations) and 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Ok
\end_layout

\end_inset

 (number of successful operations) from all the 
\series bold
\emph on
Clients
\series default
\emph default
.
 The source code of this module is like the following:
\end_layout

\begin_layout Standard

\size small
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},language=erlang"
inline false
status open

\begin_layout Plain Layout

\size small
-module(statistic).
\end_layout

\begin_layout Plain Layout

\size small
-export([start/0]).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
-ifdef(debug_statistic).
\end_layout

\begin_layout Plain Layout

\size small
-define(DBG(X,Y,Z), io:format("[STATISTIC_DEBUG] ~w: ~s ~w~n", [X, Y, Z])).
\end_layout

\begin_layout Plain Layout

\size small
-else.
\end_layout

\begin_layout Plain Layout

\size small
-define(DBG(X,Y,Z), true).
\end_layout

\begin_layout Plain Layout

\size small
-endif.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
start() ->
\end_layout

\begin_layout Plain Layout

\size small
    spawn(fun() ->
\end_layout

\begin_layout Plain Layout

\size small
                  init()
\end_layout

\begin_layout Plain Layout

\size small
          end).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
init() ->
\end_layout

\begin_layout Plain Layout

\size small
    ?DBG(statistic,"Starting the statistic thread",ok),
\end_layout

\begin_layout Plain Layout

\size small
    collect(1).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
collect(Round) -> %% Should only be called on the first execution
\end_layout

\begin_layout Plain Layout

\size small
    ?DBG(statistic,"Waiting for new data",waiting),
\end_layout

\begin_layout Plain Layout

\size small
    receive
\end_layout

\begin_layout Plain Layout

\size small
        {statistic, Round, Total, Ok} ->
\end_layout

\begin_layout Plain Layout

\size small
            ?DBG(statistic,"New Round started:",Round),
\end_layout

\begin_layout Plain Layout

\size small
            Data = {Round, Total, Ok},
\end_layout

\begin_layout Plain Layout

\size small
            collect(Round, Data, []);
\end_layout

\begin_layout Plain Layout

\size small
        stop -> %% Nothing to return, since we have no data
\end_layout

\begin_layout Plain Layout

\size small
            ?DBG(statistic,"Got a stop",exit),
\end_layout

\begin_layout Plain Layout

\size small
            ok
\end_layout

\begin_layout Plain Layout

\size small
    end.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
collect(Round, Data, Table) ->
\end_layout

\begin_layout Plain Layout

\size small
    receive
\end_layout

\begin_layout Plain Layout

\size small
        %% New execution round
\end_layout

\begin_layout Plain Layout

\size small
        {statistic, NewRound, Total, Ok} when NewRound > Round ->
\end_layout

\begin_layout Plain Layout

\size small
            ?DBG(statistic,"New Round started:",NewRound),
\end_layout

\begin_layout Plain Layout

\size small
            collect(NewRound, {NewRound, Total, Ok}, [Data|Table]);
\end_layout

\begin_layout Plain Layout

\size small
        {statistic, Round, Total, Ok} ->
\end_layout

\begin_layout Plain Layout

\size small
            {_, Total2, Ok2} = Data,
\end_layout

\begin_layout Plain Layout

\size small
            collect(Round, {Round, (Total2+Total)/2, (Ok2+Ok)/2}, Table);
\end_layout

\begin_layout Plain Layout

\size small
        {statistic, NewRound, _, _} ->
\end_layout

\begin_layout Plain Layout

\size small
            ?DBG(statistic,"FATAL! Should not receive delayed statistics!",NewRo
und),
\end_layout

\begin_layout Plain Layout

\size small
            false;
\end_layout

\begin_layout Plain Layout

\size small
        stop ->
\end_layout

\begin_layout Plain Layout

\size small
            ?DBG(statistic,"Received a stop! Presenting the data!",stop),
\end_layout

\begin_layout Plain Layout

\size small
            presentData([Data|Table])
\end_layout

\begin_layout Plain Layout

\size small
    end.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
presentData(Table) ->
\end_layout

\begin_layout Plain Layout

\size small
    io:format("Printing the Table of statistics~n~n"),
\end_layout

\begin_layout Plain Layout

\size small
    lists:map(fun(X) ->
\end_layout

\begin_layout Plain Layout

\size small
                      {Round, Total, Ok} = X,
\end_layout

\begin_layout Plain Layout

\size small
                      io:format("Round ~w TOTAL: ~w, OK: ~w, -> ~w % ~n",
\end_layout

\begin_layout Plain Layout

\size small
                                [Round, Total, Ok, 100*Ok/Total])
\end_layout

\begin_layout Plain Layout

\size small
              end,
\end_layout

\begin_layout Plain Layout

\size small
              Table).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This thread is going to be created and registered by the 
\series bold
\emph on
Opty
\series default
\emph default
 which was also modified.
 A new function 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

starttests()
\end_layout

\end_inset

 was added because a inside it a big table containing the desired execution
 parameters can be set.
 Also the 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

start()
\end_layout

\end_inset

 was then modified to receive a few other parameters:
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Round
\end_layout

\end_inset

 the number of the current round used by the 
\series bold
\emph on
Statistic
\series default
\emph default
 thread.
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Sleep
\end_layout

\end_inset

 the number of time each operation will take inside the 
\series bold
\emph on
Client
\series default
\emph default
.
 Which means the time between 
\emph on
read
\emph default
 operations and a 
\emph on
commit
\emph default
 to that same 
\series bold
\emph on
Entry
\series default
\emph default
.
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Read
\end_layout

\end_inset

 the number of 
\emph on
read
\emph default
 operations that will be executed per transaction.
 On the original code one 
\emph on
read
\emph default
 and one 
\emph on
write
\emph default
 were being executed per transaction, with this we can vary this number.
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Write
\end_layout

\end_inset

 same description as the previous, but about 
\emph on
write
\emph default
 operations.
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Slice
\end_layout

\end_inset

 the part of the total number of 
\series bold
\emph on
Entries
\series default
\emph default
 each 
\series bold
\emph on
Client
\series default
\emph default
 will be able to 
\emph on
see
\emph default
 during each transaction.
 On the original code, the 
\series bold
\emph on
Clients
\series default
\emph default
 are able to access all the pool of 
\series bold
\emph on
Entries
\series default
\emph default
 available.
\end_layout

\begin_layout Standard
The final version of the 
\series bold
\emph on
Opty
\series default
\emph default
 module after these changes, is like the following:
\end_layout

\begin_layout Standard

\size small
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},language=erlang"
inline false
status open

\begin_layout Plain Layout

\size small
-module(opty).
\end_layout

\begin_layout Plain Layout

\size small
-export([stop/1, starttests/0]).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
start(Clients, Entries, Updates, Time, Round, Sleep, Read, Write, Slice)
 ->
\end_layout

\begin_layout Plain Layout

\size small
    register(s, server:start(Entries)),
\end_layout

\begin_layout Plain Layout

\size small
    L = startClients(Clients, [], Entries, Updates, Round, Sleep,
\end_layout

\begin_layout Plain Layout

\size small
                     Read, Write, Slice),
\end_layout

\begin_layout Plain Layout

\size small
    io:format("#~w Starting: ~w CLIENTS, ~w ENTRIES, " ++
\end_layout

\begin_layout Plain Layout

\size small
              "~w UPDATES PER TRANSACTION, DURATION ~w s, " ++
\end_layout

\begin_layout Plain Layout

\size small
              "TRANSACTION DURATION ~w ms, READ ~w, WRITE ~w, SLICE ~w~n",
\end_layout

\begin_layout Plain Layout

\size small
              [Round, Clients, Entries, Updates, Time, Sleep,
\end_layout

\begin_layout Plain Layout

\size small
               Read, Write, Slice]),
\end_layout

\begin_layout Plain Layout

\size small
    timer:sleep(Time*1000),
\end_layout

\begin_layout Plain Layout

\size small
    stop(L).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
starttests() ->
\end_layout

\begin_layout Plain Layout

\size small
    register(stat, statistic:start()),
\end_layout

\begin_layout Plain Layout

\size small
    %%       {Clients, Entries, Updates, Time, Round, Sleep, Read, Write,
 Slice}
\end_layout

\begin_layout Plain Layout

\size small
    Tests = [{      8,       1,       4,   20,     1,     0,    1,     1,
     1},
\end_layout

\begin_layout Plain Layout

\size small
             (...)
\end_layout

\begin_layout Plain Layout

\size small
             {      8,      48,       4,   20,    48,     0,    1,     1,0.0833}]
,
\end_layout

\begin_layout Plain Layout

\size small
    lists:map(fun(T) ->
\end_layout

\begin_layout Plain Layout

\size small
                      {Clients, Entries, Updates, Time, Round, Sleep,
\end_layout

\begin_layout Plain Layout

\size small
                       Read, Write, Slice} = T,
\end_layout

\begin_layout Plain Layout

\size small
                      start(Clients, Entries, Updates, Time, Round, Sleep,
\end_layout

\begin_layout Plain Layout

\size small
                            Read, Write, Slice),
\end_layout

\begin_layout Plain Layout

\size small
                      %% Small sleep to avoid CPU overheating
\end_layout

\begin_layout Plain Layout

\size small
                      timer:sleep(Time*350)
\end_layout

\begin_layout Plain Layout

\size small
              end,
\end_layout

\begin_layout Plain Layout

\size small
              Tests),
\end_layout

\begin_layout Plain Layout

\size small
    timer:sleep(5000),
\end_layout

\begin_layout Plain Layout

\size small
    stat ! stop.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
stop(L) ->
\end_layout

\begin_layout Plain Layout

\size small
    io:format("Stopping...~n"),
\end_layout

\begin_layout Plain Layout

\size small
    stopClients(L),
\end_layout

\begin_layout Plain Layout

\size small
    s ! stop,
\end_layout

\begin_layout Plain Layout

\size small
    unregister(s).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
startClients(0,L,_,_,_,_,_,_,_) -> L;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
startClients(Clients, L, Entries, Updates, Round, Sleep, Read, Write, Slice)
 ->
\end_layout

\begin_layout Plain Layout

\size small
    Pid = client:start(Clients, Entries, Updates, s, Round, Sleep,
\end_layout

\begin_layout Plain Layout

\size small
                       Read, Write, Slice),
\end_layout

\begin_layout Plain Layout

\size small
    startClients(Clients-1, [Pid|L], Entries, Updates, Round, Sleep,
\end_layout

\begin_layout Plain Layout

\size small
                 Read, Write, Slice).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
stopClients([]) -> ok;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
stopClients([Pid|L]) ->
\end_layout

\begin_layout Plain Layout

\size small
    Pid ! {stop, self()},
\end_layout

\begin_layout Plain Layout

\size small
    receive
\end_layout

\begin_layout Plain Layout

\size small
        {done, Pid} -> ok
\end_layout

\begin_layout Plain Layout

\size small
    end,
\end_layout

\begin_layout Plain Layout

\size small
    stopClients(L).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\series bold
\emph on
Client
\series default
\emph default
 module was also modified to fit the modifications of the 
\series bold
\emph on
Opty
\series default
\emph default
 module as well as to send information relative to the execution to the
 
\series bold
\emph on
Statistic
\series default
\emph default
 thread instead of the terminal, as on the original code.
\end_layout

\begin_layout Standard
Now when receiving a 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

stop
\end_layout

\end_inset

 from the 
\series bold
\emph on
Opty
\series default
\emph default
 it will send a 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

{statistic, Round, Total, Ok}
\end_layout

\end_inset

 message to the now registered 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

stat
\end_layout

\end_inset

 
\series bold
\emph on
Statistic
\series default
\emph default
 thread.
 It will now use the 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Read
\end_layout

\end_inset

 and 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Write
\end_layout

\end_inset

 values to send a different number of 
\emph on
read
\emph default
 and 
\emph on
write
\emph default
 operations per transaction.
 To do it, the 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

do_transactions()
\end_layout

\end_inset

 function was modified to count down the number of both remaining operations.
 When there are both 
\emph on
read
\emph default
 and 
\emph on
write
\emph default
 operations to be done, the code stayed the same, but of course when there
 are only one of them, the other is not processed.
 Also to provide the use of the 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Slice
\end_layout

\end_inset

 variable, for each transaction a new interval of visible 
\series bold
\emph on
Entries
\series default
\emph default
 is calculated.
 To do it, we multiple the total number of 
\series bold
\emph on
Entries
\series default
\emph default
 by 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Slice
\end_layout

\end_inset

, let's call it 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

SliceSize
\end_layout

\end_inset

, we then randomly choose a number to be our 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

MinEntry
\end_layout

\end_inset

 as the minimal 
\series bold
\emph on
Entry
\series default
\emph default
 id it can access.
 Finally with these two number for that transaction, the 
\series bold
\emph on
Client
\series default
\emph default
 will only be able to access the interval of 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

SliceSize
\end_layout

\end_inset

 where 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

MinEntry
\end_layout

\end_inset

 is the smallest 
\series bold
\emph on
Entry
\series default
\emph default
 id it can get.
 Of course that some boundary checks are also made.
\end_layout

\begin_layout Standard
The final version of these modified parts of this module, will look like
 the following:
\end_layout

\begin_layout Standard

\size small
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},language=erlang"
inline false
status open

\begin_layout Plain Layout

\size small
(...)
\end_layout

\begin_layout Plain Layout

\size small
open(Name, Entries, Updates, Server, Total, Ok, Round, Sleep,
\end_layout

\begin_layout Plain Layout

\size small
     Read, Write, Slice) ->
\end_layout

\begin_layout Plain Layout

\size small
    {A1,A2,A3} = now(),
\end_layout

\begin_layout Plain Layout

\size small
    random:seed(A1, A2, A3),
\end_layout

\begin_layout Plain Layout

\size small
    Server ! {open, self()},
\end_layout

\begin_layout Plain Layout

\size small
    receive
\end_layout

\begin_layout Plain Layout

\size small
        {stop, From} ->
\end_layout

\begin_layout Plain Layout

\size small
            %io:format("~w: Transactions TOTAL:~w, OK:~w, -> ~w % ~n",
\end_layout

\begin_layout Plain Layout

\size small
            %          [Name, Total, Ok, 100*Ok/Total]),
\end_layout

\begin_layout Plain Layout

\size small
            stat ! {statistic, Round, Total, Ok},
\end_layout

\begin_layout Plain Layout

\size small
            From ! {done, self()},
\end_layout

\begin_layout Plain Layout

\size small
            ok;
\end_layout

\begin_layout Plain Layout

\size small
        {transaction, Validator, Store} ->
\end_layout

\begin_layout Plain Layout

\size small
            ?DBG(Name,"Received a transaction message from the server!",ok),
\end_layout

\begin_layout Plain Layout

\size small
            Handler = handler:start(self(), Validator, Store),
\end_layout

\begin_layout Plain Layout

\size small
            MinEntry = random:uniform(Entries),
\end_layout

\begin_layout Plain Layout

\size small
            SliceSize = round(Entries * Slice),
\end_layout

\begin_layout Plain Layout

\size small
            if
\end_layout

\begin_layout Plain Layout

\size small
                (MinEntry + SliceSize) > Entries ->
\end_layout

\begin_layout Plain Layout

\size small
                    Entries2 = (Entries - SliceSize),
\end_layout

\begin_layout Plain Layout

\size small
                    do_transactions(Name, Entries, Entries2, Updates, Server,
\end_layout

\begin_layout Plain Layout

\size small
                                    Handler, Total, Ok, Updates, Round,
 Sleep,
\end_layout

\begin_layout Plain Layout

\size small
                                    Read, Read, Write, Write, Slice);
\end_layout

\begin_layout Plain Layout

\size small
                true ->
\end_layout

\begin_layout Plain Layout

\size small
                    Entries2 = MinEntry,
\end_layout

\begin_layout Plain Layout

\size small
                    do_transactions(Name, Entries, Entries2, Updates, Server,
\end_layout

\begin_layout Plain Layout

\size small
                                    Handler, Total, Ok, Updates, Round,
 Sleep,
\end_layout

\begin_layout Plain Layout

\size small
                                    Read, Read, Write, Write, Slice)
\end_layout

\begin_layout Plain Layout

\size small
            end
\end_layout

\begin_layout Plain Layout

\size small
    end.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
% Commit transaction
\end_layout

\begin_layout Plain Layout

\size small
do_transactions(Name, Entries, _, Updates, Server, Handler, Total, Ok, 0,
\end_layout

\begin_layout Plain Layout

\size small
                Round, Sleep, Read, _, Write, _, Slice) ->
\end_layout

\begin_layout Plain Layout

\size small
    %%%
\end_layout

\begin_layout Plain Layout

\size small
    %% This line is going to be used to modify the amount of time each
\end_layout

\begin_layout Plain Layout

\size small
    %% transaction will take
\end_layout

\begin_layout Plain Layout

\size small
    %%%
\end_layout

\begin_layout Plain Layout

\size small
    timer:sleep(Sleep),
\end_layout

\begin_layout Plain Layout

\size small
    Ref = make_ref(),
\end_layout

\begin_layout Plain Layout

\size small
    Handler ! {commit, Ref},
\end_layout

\begin_layout Plain Layout

\size small
    Result = receiveCommitValue(Ref),
\end_layout

\begin_layout Plain Layout

\size small
    if
\end_layout

\begin_layout Plain Layout

\size small
        Result == ok ->
\end_layout

\begin_layout Plain Layout

\size small
            open(Name, Entries, Updates, Server, Total+1, Ok+1, Round, Sleep,
\end_layout

\begin_layout Plain Layout

\size small
                 Read, Write, Slice);
\end_layout

\begin_layout Plain Layout

\size small
        Result == stop ->
\end_layout

\begin_layout Plain Layout

\size small
            close(Name, Total, Ok, Round);
\end_layout

\begin_layout Plain Layout

\size small
        true ->
\end_layout

\begin_layout Plain Layout

\size small
            open(Name, Entries, Updates, Server, Total+1, Ok, Round, Sleep,
\end_layout

\begin_layout Plain Layout

\size small
                 Read, Write, Slice)
\end_layout

\begin_layout Plain Layout

\size small
    end;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
% Reads and Writes
\end_layout

\begin_layout Plain Layout

\size small
do_transactions(Name, Entries, MyEntries, Updates, Server, Handler, Total,
 Ok,
\end_layout

\begin_layout Plain Layout

\size small
                N, Round, Sleep, Read, 0, Write, 0, Slice) ->
\end_layout

\begin_layout Plain Layout

\size small
    do_transactions(Name, Entries, MyEntries, Updates, Server, Handler,
 Total,
\end_layout

\begin_layout Plain Layout

\size small
                    Ok, N-1, Round, Sleep, Read, Read, Write, Write, Slice);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
do_transactions(Name, Entries, MyEntries, Updates, Server, Handler, Total,
 Ok,
\end_layout

\begin_layout Plain Layout

\size small
                N, Round, Sleep, Read, R, Write, 0, Slice) ->
\end_layout

\begin_layout Plain Layout

\size small
    Ref = make_ref(),
\end_layout

\begin_layout Plain Layout

\size small
    RndNum = random:uniform(round(Entries*Slice)),
\end_layout

\begin_layout Plain Layout

\size small
    Num = MyEntries + RndNum,
\end_layout

\begin_layout Plain Layout

\size small
    Handler ! {read, Ref, Num},
\end_layout

\begin_layout Plain Layout

\size small
    Value = receiveValue(Ref),
\end_layout

\begin_layout Plain Layout

\size small
    if
\end_layout

\begin_layout Plain Layout

\size small
        Value == stop ->
\end_layout

\begin_layout Plain Layout

\size small
            close(Name, Total, Ok, Round);
\end_layout

\begin_layout Plain Layout

\size small
        true ->
\end_layout

\begin_layout Plain Layout

\size small
            do_transactions(Name, Entries, MyEntries, Updates, Server, Handler,
\end_layout

\begin_layout Plain Layout

\size small
                         Total, Ok, N, Round, Sleep, Read, R-1, Write, 0,
 Slice)
\end_layout

\begin_layout Plain Layout

\size small
    end;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
do_transactions(Name, Entries, MyEntries, Updates, Server, Handler, Total,
 Ok,
\end_layout

\begin_layout Plain Layout

\size small
                N, Round, Sleep, Read, 0, Write, W, Slice) ->
\end_layout

\begin_layout Plain Layout

\size small
    RndNum = random:uniform(round(Entries*Slice)),
\end_layout

\begin_layout Plain Layout

\size small
    Num = MyEntries + RndNum,
\end_layout

\begin_layout Plain Layout

\size small
    Handler ! {write, Num, Name+Num+1},
\end_layout

\begin_layout Plain Layout

\size small
    do_transactions(Name, Entries, MyEntries, Updates, Server, Handler,
 Total,
\end_layout

\begin_layout Plain Layout

\size small
                    Ok, N, Round, Sleep, Read, 0, Write, W-1, Slice);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size small
do_transactions(Name, Entries, MyEntries, Updates, Server, Handler, Total,
 Ok,
\end_layout

\begin_layout Plain Layout

\size small
                N, Round, Sleep, Read, R, Write, W, Slice) ->
\end_layout

\begin_layout Plain Layout

\size small
    Ref = make_ref(),
\end_layout

\begin_layout Plain Layout

\size small
    RndNum = random:uniform(round(Entries*Slice)),
\end_layout

\begin_layout Plain Layout

\size small
    Num = MyEntries + RndNum,
\end_layout

\begin_layout Plain Layout

\size small
    ?DBG(Name,"{RndNum,Num}",{RndNum,Num}),
\end_layout

\begin_layout Plain Layout

\size small
    Handler ! {read, Ref, Num},
\end_layout

\begin_layout Plain Layout

\size small
    Value = receiveValue(Ref),
\end_layout

\begin_layout Plain Layout

\size small
    if
\end_layout

\begin_layout Plain Layout

\size small
        Value == stop ->
\end_layout

\begin_layout Plain Layout

\size small
            close(Name, Total, Ok, Round);
\end_layout

\begin_layout Plain Layout

\size small
        true ->
\end_layout

\begin_layout Plain Layout

\size small
            Handler ! {write, Num, Value+1},
\end_layout

\begin_layout Plain Layout

\size small
            do_transactions(Name, Entries, MyEntries, Updates, Server, Handler,
\end_layout

\begin_layout Plain Layout

\size small
                       Total, Ok, N, Round, Sleep, Read, R-1, Write, W-1,
 Slice)
\end_layout

\begin_layout Plain Layout

\size small
    end.
\end_layout

\begin_layout Plain Layout

\size small
(...)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Finally the questions are the following:
\end_layout

\begin_layout Itemize

\emph on
What is the impact of the number of concurrent transactions on the success
 rate (i.e.
 percentage of committed transactions with respect to the total)?
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
Different number of entries in the store.
\end_layout

\begin_layout Standard
Executing with different number of 
\series bold
\emph on
Entries
\series default
\emph default
 and keeping the other parameters constant, as this number rises in relation
 to the total number of transactions made per iteration (
\series bold
\emph on
Clients
\series default
\emph default
 * 
\series bold
\emph on
Update
\series default
\emph default
), the number of successful transactions increase.
 And this was of course expected because with very few available 
\series bold
\emph on
Entries
\series default
\emph default
 the chances of conflicting operations are much higher.
\end_layout

\begin_layout Standard
The following values come from the execution of this modified version of
 the code for benchmarking:
\end_layout

\begin_layout Standard

\size small
Round 12 TOTAL: 115209.984375, OK: 78055.484375, -> 67.7506249119 %
\end_layout

\begin_layout Standard

\size small
Round 11 TOTAL: 114801.2578125, OK: 72407.7265625, -> 63.0722414912 %
\end_layout

\begin_layout Standard

\size small
Round 10 TOTAL: 124077.6796875, OK: 68608.21875, -> 55.2945694364 %
\end_layout

\begin_layout Standard

\size small
Round 9 TOTAL: 126521.859375, OK: 62901.3125, -> 49.71576675 %
\end_layout

\begin_layout Standard

\size small
Round 8 TOTAL: 130798.5859375, OK: 55199.0703125, -> 42.20158032815 %
\end_layout

\begin_layout Standard

\size small
Round 7 TOTAL: 133990.109375, OK: 49639.734375, -> 37.0473123774 %
\end_layout

\begin_layout Standard

\size small
Round 6 TOTAL: 136016.6015625, OK: 42315.8203125, -> 31.1107760570 %
\end_layout

\begin_layout Standard

\size small
Round 5 TOTAL: 148077.796875, OK: 34185.4453125, -> 23.08613852578 %
\end_layout

\begin_layout Standard

\size small
Round 4 TOTAL: 149645.9375, OK: 30995.2734375, -> 20.71240553222 %
\end_layout

\begin_layout Standard

\size small
Round 3 TOTAL: 159031.1640625, OK: 28995.5078125, -> 18.23259483977 %
\end_layout

\begin_layout Standard

\size small
Round 2 TOTAL: 178410.8125, OK: 29259.0390625, -> 16.39981268652 %
\end_layout

\begin_layout Standard

\size small
Round 1 TOTAL: 199755.9765625, OK: 33719.5625, -> 16.88037728846 %
\end_layout

\begin_layout Standard
And the 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Multiple-Entries"

\end_inset

 shows a chart showing the relation between the number of 
\series bold
\emph on
Entries
\series default
\emph default
 and the percentage of successful operations.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename seminar5/chart_entries.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Multiple Entries
\begin_inset CommandInset label
LatexCommand label
name "fig:Multiple-Entries"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Different duration of the transactions (e.g.
 each transaction takes around 1 second to commit).
\end_layout

\begin_layout Standard
By increasing the duration of the transactions the total number of transactions
 decrease.
 That's because now, each client is taking longer to decide when to finally
 commit the changes, causing more conflicting operations tough the ratio
 between Total and OK (successful) stays the same.
\end_layout

\begin_layout Standard
These are the values for this execution:
\end_layout

\begin_layout Standard

\size small
Round 24 TOTAL: 647.3515625, OK: 256.0390625, -> 39.5517794861 %
\end_layout

\begin_layout Standard

\size small
Round 23 TOTAL: 1054.21875, OK: 426.46875, -> 40.45353490440 %
\end_layout

\begin_layout Standard

\size small
Round 22 TOTAL: 1333.2421875, OK: 553.1484375, -> 41.4889689724 %
\end_layout

\begin_layout Standard

\size small
Round 21 TOTAL: 1815.640625, OK: 733.5390625, -> 40.4011153088 %
\end_layout

\begin_layout Standard

\size small
Round 20 TOTAL: 1992.703125, OK: 845.2265625, -> 42.4160805438 %
\end_layout

\begin_layout Standard

\size small
Round 19 TOTAL: 2494.5859375, OK: 1073.1953125, -> 43.0209798093 %
\end_layout

\begin_layout Standard

\size small
Round 18 TOTAL: 3307.203125, OK: 1402.7421875, -> 42.4147575604 %
\end_layout

\begin_layout Standard

\size small
Round 17 TOTAL: 3934.234375, OK: 1721.046875, -> 43.74540789782 %
\end_layout

\begin_layout Standard

\size small
Round 16 TOTAL: 4914.4453125, OK: 2127.953125, -> 43.2999655034 %
\end_layout

\begin_layout Standard

\size small
Round 15 TOTAL: 6473.9765625, OK: 2806.609375, -> 43.3521707702 %
\end_layout

\begin_layout Standard

\size small
Round 14 TOTAL: 9751.0390625, OK: 4383.546875, -> 44.95466428657 %
\end_layout

\begin_layout Standard

\size small
Round 13 TOTAL: 124902.1953125, OK: 62190.5390625, -> 49.7913899006 %
\end_layout

\begin_layout Standard
And the
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Different-duration"

\end_inset

 shows a chart showing the relation between the duration of the transactions
 and the total number of them.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename seminar5/chart_sleep.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Different duration
\begin_inset CommandInset label
LatexCommand label
name "fig:Different-duration"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Different ratio of read and write operations per transaction.
\end_layout

\begin_layout Standard
As the number of 
\emph on
read
\emph default
 operations decrease in relation to the number of 
\emph on
write
\emph default
 operations, the total number of transactions increase.
 That can be explained by the fact that 
\emph on
read
\emph default
 operations need an response from the given 
\series bold
\emph on
Entry
\series default
\emph default
 with the requested value and also before committing all these 
\emph on
read
\emph default
 operations will be validated, while the 
\emph on
write
\emph default
 operations are less costly.
\end_layout

\begin_layout Standard
These are the values for this execution:
\end_layout

\begin_layout Standard

\size small
Round 36 TOTAL: 60987.765625, OK: 60987.765625, -> 100.0 %
\end_layout

\begin_layout Standard

\size small
Round 35 TOTAL: 60792.1484375, OK: 11867.640625, -> 19.52166674484 %
\end_layout

\begin_layout Standard

\size small
Round 34 TOTAL: 51427.546875, OK: 7854.3671875, -> 15.2726849028 %
\end_layout

\begin_layout Standard

\size small
Round 33 TOTAL: 45216.9296875, OK: 6240.4140625, -> 13.80105660784 %
\end_layout

\begin_layout Standard

\size small
Round 32 TOTAL: 40087.703125, OK: 5459.8359375, -> 13.61972752710 %
\end_layout

\begin_layout Standard

\size small
Round 31 TOTAL: 33719.984375, OK: 4598.1171875, -> 13.63617828633 %
\end_layout

\begin_layout Standard

\size small
Round 30 TOTAL: 31804.9296875, OK: 4383.359375, -> 13.78201246809 %
\end_layout

\begin_layout Standard

\size small
Round 29 TOTAL: 26702.8984375, OK: 3662.75, -> 13.71667577050 %
\end_layout

\begin_layout Standard

\size small
Round 28 TOTAL: 24525.375, OK: 3336.984375, -> 13.60625219797 %
\end_layout

\begin_layout Standard

\size small
Round 27 TOTAL: 23135.4765625, OK: 3362.6484375, -> 14.53459767044 %
\end_layout

\begin_layout Standard

\size small
Round 26 TOTAL: 20537.5, OK: 3717.5703125, -> 18.10137705416 %
\end_layout

\begin_layout Standard

\size small
Round 25 TOTAL: 17045.6015625, OK: 17045.6015625, -> 100.0 %
\end_layout

\begin_layout Standard
And the 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Read/Write-ratio"

\end_inset

 shows a chart showing the relation between the number of 
\emph on
reads
\emph default
 operations and the total number of transactions.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename seminar5/chart_ratio.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Read/Write ratio
\begin_inset CommandInset label
LatexCommand label
name "fig:Read/Write-ratio"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Different percentage of modified entries with respect to the total number
 of entries (e.g.
 each transaction modifies randomly 20% of entries).
\end_layout

\begin_layout Standard
When a 
\series bold
\emph on
Client
\series default
\emph default
 has a smaller view of the whole pool of 
\series bold
\emph on
Entries
\series default
\emph default
 available the ratio of total completed transactions is also higher.
 That can be explained by the fact that when each 
\series bold
\emph on
Client
\series default
\emph default
 can reach a smaller number of 
\series bold
\emph on
Entries
\series default
\emph default
, the chances of conflicting operations between the clients decreases when
 compared to the whole system view
\end_layout

\begin_layout Standard
These are the values for this execution:
\end_layout

\begin_layout Standard

\size small
Round 48 TOTAL: 141994.765625, OK: 110542.734375, -> 77.8498657245 %
\end_layout

\begin_layout Standard

\size small
Round 47 TOTAL: 135576.0078125, OK: 80563.5546875, -> 59.4231649001 %
\end_layout

\begin_layout Standard

\size small
Round 46 TOTAL: 131083.484375, OK: 69761.9140625, -> 53.2194535376 %
\end_layout

\begin_layout Standard

\size small
Round 45 TOTAL: 131141.140625, OK: 66240.953125, -> 50.5111918420 %
\end_layout

\begin_layout Standard

\size small
Round 44 TOTAL: 127070.25, OK: 61980.65625, -> 48.7766855341 %
\end_layout

\begin_layout Standard

\size small
Round 43 TOTAL: 127314.75, OK: 59178.96875, -> 46.4824136637 %
\end_layout

\begin_layout Standard

\size small
Round 42 TOTAL: 128353.9453125, OK: 58283.4375, -> 45.40837241745 %
\end_layout

\begin_layout Standard

\size small
Round 41 TOTAL: 127892.984375, OK: 57772.0390625, -> 45.1721721444 %
\end_layout

\begin_layout Standard

\size small
Round 40 TOTAL: 128986.5390625, OK: 58862.1171875, -> 45.63431007244%
\end_layout

\begin_layout Standard

\size small
Round 39 TOTAL: 129774.09375, OK: 60406.4765625, -> 46.5474077429 %
\end_layout

\begin_layout Standard

\size small
Round 38 TOTAL: 128198.9765625, OK: 61534.875, -> 47.99950565127 %
\end_layout

\begin_layout Standard

\size small
Round 37 TOTAL: 126797.65625, OK: 63074.3828125, -> 49.7441235728 %
\end_layout

\begin_layout Standard
And the 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Different-percentage"

\end_inset

 shows a chart showing the relation between the percentage of the number
 of 
\series bold
\emph on
Entries
\series default
\emph default
 each 
\series bold
\emph on
Client
\series default
\emph default
 can reach and the total number of successful operations.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename seminar5/chart_slice.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Different percentage
\begin_inset CommandInset label
LatexCommand label
name "fig:Different-percentage"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\emph on
Split the 
\series bold
\emph default
opty
\series default
\emph on
 module in two parts and make the needed adaptaions to enable the server
 and clients to run in different machines.
 If we run this in a distributed Erlang network, where is the handler running?
 What is actually copied when a transaction handler is started?
\end_layout

\begin_layout Standard

\bar under
Note
\bar default
: the source code for this part is on the 
\emph on
src/
\emph default
 directory that follows this document.
\end_layout

\begin_layout Standard
To split the code between multiple machines where the 
\series bold
\emph on
Server
\series default
\emph default
 will run in one machine and multiple instances of 
\series bold
\emph on
Clients
\series default
\emph default
 can run on multiple other machines we just separated the 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

startClient()
\end_layout

\end_inset

 and 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

stopClient()
\end_layout

\end_inset

 functions to a different module, 
\emph on
opty_client.erl
\emph default
 and make it send a message 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

{clientOpty, self()}
\end_layout

\end_inset

 to the 
\emph on
opty_server.erl
\emph default
 module and wait for the number of 
\series bold
\emph on
Entries
\series default
\emph default
, finally this module will enter the 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

waitStop()
\end_layout

\end_inset

 state where it will wait for a 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

stop
\end_layout

\end_inset

 message from the 
\emph on
opty_server
\emph default
 module to stop all the existing 
\series bold
\emph on
Clients
\series default
\emph default
.
 The 
\emph on
opty_server.erl
\emph default
 module after sending the needed information to the 
\emph on
opty_client
\emph default
 will wait for a timeout to stop the execution of the whole system by stopping
 the running elements.
\end_layout

\begin_layout Standard
The final version of both of these codes is like the following:
\end_layout

\begin_layout Standard

\size small
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},language=erlang"
inline false
status open

\begin_layout Plain Layout

-module(opty_server).
\end_layout

\begin_layout Plain Layout

-export([start/2]).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-ifdef(debug_opty).
\end_layout

\begin_layout Plain Layout

-define(DBG(X,Y,Z),
\end_layout

\begin_layout Plain Layout

io:format("[OPTY_SERVER_DEBUG] ~w: ~s ~w~n", [X, Y, Z])).
\end_layout

\begin_layout Plain Layout

-else.
\end_layout

\begin_layout Plain Layout

-define(DBG(X,Y,Z), true).
\end_layout

\begin_layout Plain Layout

-endif.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

start(Entries, Time) ->
\end_layout

\begin_layout Plain Layout

    ?DBG(server,"Starting the server",ok),
\end_layout

\begin_layout Plain Layout

    register(server, self()),
\end_layout

\begin_layout Plain Layout

    register(s, server:start(Entries)),
\end_layout

\begin_layout Plain Layout

    ClientsOpty = waitClients(na, Entries, Time),
\end_layout

\begin_layout Plain Layout

    ?DBG(server,"Content of ClientsOpty",ClientsOpty),
\end_layout

\begin_layout Plain Layout

    stop(ClientsOpty).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

waitClients(na, Entries, Time) ->
\end_layout

\begin_layout Plain Layout

    ?DBG(server,"Waiting for messages from the client Opty.", waiting),
\end_layout

\begin_layout Plain Layout

    receive
\end_layout

\begin_layout Plain Layout

        {clientOpty, From} ->
\end_layout

\begin_layout Plain Layout

            ?DBG(server,"Got the first client opty message", From),
\end_layout

\begin_layout Plain Layout

            From ! {entry, Entries},
\end_layout

\begin_layout Plain Layout

            waitClients(From, Entries, Time);
\end_layout

\begin_layout Plain Layout

        _ ->
\end_layout

\begin_layout Plain Layout

            io:format("[WARN] How can I receive anything else now?~n"),
\end_layout

\begin_layout Plain Layout

            waitClients(na, Entries, Time)
\end_layout

\begin_layout Plain Layout

    end;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

waitClients(L, Entries, Time) ->
\end_layout

\begin_layout Plain Layout

    receive
\end_layout

\begin_layout Plain Layout

        {clientOpty, From} ->
\end_layout

\begin_layout Plain Layout

            ?DBG(server,"Got another client opty request", From),
\end_layout

\begin_layout Plain Layout

            From ! {entry, Entries},
\end_layout

\begin_layout Plain Layout

            waitClients([From|L], Entries, Time);
\end_layout

\begin_layout Plain Layout

        _ ->
\end_layout

\begin_layout Plain Layout

            io:format("[WARN] How can I receive anything else now?~n"),
\end_layout

\begin_layout Plain Layout

            waitClients(L, Entries, Time)
\end_layout

\begin_layout Plain Layout

    after
\end_layout

\begin_layout Plain Layout

        (Time*1000) ->
\end_layout

\begin_layout Plain Layout

            ?DBG(server,"Timeout! Time to stop the execution", (Time*1000)),
\end_layout

\begin_layout Plain Layout

            L
\end_layout

\begin_layout Plain Layout

    end.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

stop(L) ->
\end_layout

\begin_layout Plain Layout

    io:format("Stopping...~n"),
\end_layout

\begin_layout Plain Layout

    stopClients(L),
\end_layout

\begin_layout Plain Layout

    s ! stop.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

stopClients([]) -> ok;
\end_layout

\begin_layout Plain Layout

stopClients([Pid|L]) ->
\end_layout

\begin_layout Plain Layout

    Pid ! {stop,server},
\end_layout

\begin_layout Plain Layout

    stopClients(L);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

stopClients(L) ->
\end_layout

\begin_layout Plain Layout

    L ! {stop,server},
\end_layout

\begin_layout Plain Layout

    stopClients([]).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-module(opty_client).
\end_layout

\begin_layout Plain Layout

-export([start/4]).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-ifdef(debug_opty).
\end_layout

\begin_layout Plain Layout

-define(DBG(X,Y,Z),
\end_layout

\begin_layout Plain Layout

io:format("[OPTY_CLIENT_DEBUG] ~w: ~s ~w~n", [X, Y, Z])).
\end_layout

\begin_layout Plain Layout

-else.
\end_layout

\begin_layout Plain Layout

-define(DBG(X,Y,Z), true).
\end_layout

\begin_layout Plain Layout

-endif.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

start(Clients, Updates, Server, ServerOpty) ->
\end_layout

\begin_layout Plain Layout

    ?DBG(clients,"Starting the clients", ok),
\end_layout

\begin_layout Plain Layout

    ServerOpty ! {clientOpty, self()},
\end_layout

\begin_layout Plain Layout

    receive
\end_layout

\begin_layout Plain Layout

        {entry, Entries} ->
\end_layout

\begin_layout Plain Layout

            ?DBG(clients,"Got the entries from the server", Entries),
\end_layout

\begin_layout Plain Layout

            L = startClients(Clients, [], Entries, Updates, Server),
\end_layout

\begin_layout Plain Layout

            io:format("Starting: ~w CLIENTS, ~w ENTRIES, " ++
\end_layout

\begin_layout Plain Layout

                          "~w UPDATES PER TRANSACTION ~n",
\end_layout

\begin_layout Plain Layout

                      [Clients, Entries, Updates]),
\end_layout

\begin_layout Plain Layout

            waitStop(L)
\end_layout

\begin_layout Plain Layout

    end.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

waitStop(L) ->
\end_layout

\begin_layout Plain Layout

    receive
\end_layout

\begin_layout Plain Layout

        {stop, server} ->
\end_layout

\begin_layout Plain Layout

            ?DBG(clients,"Got a stop from the server!", stop),
\end_layout

\begin_layout Plain Layout

            stopClients(L)
\end_layout

\begin_layout Plain Layout

    end.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

startClients(0,L,_,_,_) -> L;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

startClients(Clients, L, Entries, Updates, Server) ->
\end_layout

\begin_layout Plain Layout

    Pid = client:start(Clients, Entries, Updates, Server),
\end_layout

\begin_layout Plain Layout

    startClients(Clients-1, [Pid|L], Entries, Updates, Server).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

stopClients([]) -> ok;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

stopClients([Pid|L]) ->
\end_layout

\begin_layout Plain Layout

    ?DBG(clients,"Stopping client:",Pid),
\end_layout

\begin_layout Plain Layout

    Pid ! {stop, self()},
\end_layout

\begin_layout Plain Layout

    receive
\end_layout

\begin_layout Plain Layout

        {done, Pid} ->
\end_layout

\begin_layout Plain Layout

            ?DBG(clients,"Received done from",Pid),
\end_layout

\begin_layout Plain Layout

            ok
\end_layout

\begin_layout Plain Layout

    end,
\end_layout

\begin_layout Plain Layout

    stopClients(L).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Multiple-instances-running"

\end_inset

 shows this multiple instance running with two sets of clients and one server
 on a distributed Erlang environment.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename seminar5/opty_multiple.png
	lyxscale 35
	scale 20

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Multiple instances running
\begin_inset CommandInset label
LatexCommand label
name "fig:Multiple-instances-running"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Since the 
\series bold
\emph on
Client
\series default
\emph default
 code was not changed, the 
\series bold
\emph on
Handler
\series default
\emph default
 will be running on the same Erlang instance as the 
\series bold
\emph on
Client
\series default
\emph default
 that is running a transaction.
\end_layout

\begin_layout Standard
When the 
\series bold
\emph on
Handler
\series default
\emph default
 is started the PID of the 
\series bold
\emph on
Client
\series default
\emph default
 is copied, the remote address of the 
\series bold
\emph on
Validator
\series default
\emph default
 is also copied along with the tuple of available 
\series bold
\emph on
Entries
\series default
\emph default
 of the system.
\end_layout

\begin_layout Standard
A trace from the 
\series bold
\emph on
Handler
\series default
\emph default
 with the debug flag set returns the following from these values:
\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},language=erlang"
inline false
status open

\begin_layout Plain Layout

\size footnotesize
[HANDLER_DEBUG] Values started {<0.45.0>,<6531.49.0>,{<6531.48.0>,...,<6531.41.0>}}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Which corresponds to the commented values.
\end_layout

\begin_layout Section
Conclusions
\end_layout

\begin_layout Standard
With this seminar session we have learned how to implement an optimistic
 concurrency control allowing us to work on highly distributed systems without
 a locking architecture.
 This has shown to be really interesting with all the possible parameters
 that can influence the system execution and it's performance.
 
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "sodx"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
