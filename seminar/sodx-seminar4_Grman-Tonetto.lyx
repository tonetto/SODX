#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
% Very simple template for SODX lab reports. Most common packages are already included.

% Change according your file encoding
\usepackage{url}
\usepackage{placeins}

%opening
\title{Seminar Report: Paxy}
\author{Peter Grman, Leonardo Tonetto}
\date{\today{}}
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package none
\inputencoding utf8
\fontencoding default
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 0
\use_mathdots 0
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
maketitle
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
In this seminar we implemented the Paxos algorithm 
\begin_inset CommandInset citation
LatexCommand cite
key "lamport2002paxos"

\end_inset

 for gaining consensus in a distributed system where processes can propose
 values and the consensus algorithm ensures that a single one among the
 proposed values is chosen.
\end_layout

\begin_layout Standard
The basic idea of the Paxos algorithm is that a 
\series bold
\emph on
Proposer
\series default
\emph default
 attempts to ratify a proposed decision value (from an arbitrary input set)
 by collecting acceptances from a majority of the 
\series bold
\emph on
Acceptors
\series default
\emph default
, and this ratification is observed by the 
\series bold
\emph on
Learners
\series default
\emph default
.
 As will be seen in the next sections of this document we did not implement
 the 
\series bold
\emph on
Learners
\series default
 
\emph default
in this exercise but the algorithm define these main roles as follows:
\end_layout

\begin_layout Itemize

\series bold
\emph on
Acceptors
\series default
\emph default
: performing a 
\emph on
prepare
\emph default
 action they are going to decide if they will 
\emph on
promise
\emph default
 or not to vote on a sequence numbers smaller than the one it promised.
 Basically if no previous promise was made before, the first proposition
 will be taken as the first promise.
 From this point onwards, for any new 
\emph on
prepare
\emph default
 action the 
\series bold
\emph on
Acceptor
\series default
\emph default
 will only issue new promises if they ask for sequence numbers higher than
 or equal to the current promise.
 They can also perform 
\emph on
accept
\emph default
 actions which will be requested by 
\series bold
\emph on
Proposers
\series default
\emph default
 that had collected a quorum of promises for a sequence number and are asking
 now for a voting on a value that they want to reach consensus on.
\end_layout

\begin_layout Itemize

\series bold
\emph on
Proposers
\series default
\emph default
: having a 
\bar under
value
\bar default
 to be voted for they issue requests for the 
\series bold
\emph on
Acceptors
\series default
\emph default
 to perform 
\emph on
prepare
\emph default
 actions and so to promise not to vote for sequence numbers smaller than
 a certain one, once they get a quorum number of promises they will issue
 requests for the 
\series bold
\emph on
Acceptors
\series default
\emph default
 to finally perform an 
\emph on
accept
\emph default
 action and vote for the initial 
\bar under
value
\bar default
 the 
\series bold
\emph on
Proposer
\series default
\emph default
 is asking for.
 If they don't receive this amount of promises or votes a new round is started
 with a higher sequence number.
\end_layout

\begin_layout Itemize

\series bold
\emph on
Learners
\series default
\emph default
: will basically determine what is the selected value with which the system
 reached consensus upon.
\end_layout

\begin_layout Standard
It's also important to notice that the 
\series bold
\emph on
Acceptors
\series default
\emph default
 should be fault-tolerant in the sense that, after a failure if they return
 back, they should be able to recover the previous state that they left
 the system so that they can 
\emph on
remember
\emph default
 what were the promises and votes issued before the failure.
 This is usually implemented by storing the important changes in the system
 in persistent memory (i.e.
 files on a local hard disk or in a reliable remote storage node).
\end_layout

\begin_layout Standard
First we started with a simple implementation that does not have fault-tolerant
 
\series bold
\emph on
Acceptors
\series default
\emph default
 but is easily able to reach consensus even with pseudo-random message drops
 and delays, afterwards fault-tolerance is added and finally a simple tweak
 is made by counting the number of promises negated which could lead a 
\series bold
\emph on
Proposer
\series default
\emph default
 quicker to the next round (i.e.
 increase the sequence number).
\end_layout

\begin_layout Section
System overview
\end_layout

\begin_layout Standard
For this seminar the code implementations can be divided in three parts:
 basic, fault tolerant and optimized.
 Some of the suggestions asked only for the open questions section are going
 to be discussed because they make more sense here like adding delays in
 the code.
\end_layout

\begin_layout Subsection
Basic
\end_layout

\begin_layout Standard
This is the first version of the code that we had to fill in the blank spaces
 in the code while studying the Paxos algorithm.
 
\series bold
\bar under
Note
\series default
\bar default
: the source code for this part is in the 
\emph on
src/
\emph default
 directory.And again, by using macros in the Erlang code, to enable the debug
 messages the code should be compiled defining 
\emph on
debug
\emph default
.
 For example:
\end_layout

\begin_layout Standard
\align center

\emph on
$ erlc -Ddebug *.erl
\end_layout

\begin_layout Standard
This part is divided into five modules: 
\emph on
acceptor.erl
\emph default
, 
\emph on
gui.erl
\emph default
, 
\emph on
order.erl
\emph default
, 
\emph on
paxy.erl
\emph default
 and 
\emph on
proposer.erl
\emph default
.
 Please refer to 
\begin_inset CommandInset citation
LatexCommand cite
key "emdc_sodx4"

\end_inset

 for details on 
\emph on
gui
\emph default
, 
\emph on
paxy
\emph default
 and 
\emph on
order
\emph default
 modules implementation.
\end_layout

\begin_layout Subsubsection
acceptor.erl
\end_layout

\begin_layout Standard
This module, as the name suggests, implements the 
\series bold
\emph on
Acceptors
\series default
\emph default
 actions.
 After initializing the variables needed throughout the execution it enters
 the 
\emph on
acceptor
\emph default
 state where it's going to basically wait for three possible messages:
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

{prepare, Proposer, Round}
\end_layout

\end_inset

 message sent by a 
\series bold
\emph on
Proposer
\series default
\emph default
 asking for promises on the sequence number 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Round
\end_layout

\end_inset

.
 The 
\series bold
\emph on
Acceptor
\series default
\emph default
 may answer with a 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

promise
\end_layout

\end_inset

 message in case the 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Round
\end_layout

\end_inset

 is greater than the highest promise it already made, stored in 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Promise
\end_layout

\end_inset

 which will be replaced by the first one if so, or with a 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

sorry
\end_layout

\end_inset

 message otherwise.
 The 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

promise
\end_layout

\end_inset

 messages will contain the sequence number 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Round
\end_layout

\end_inset

 they are promising and previous values already voted, 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Accepted
\end_layout

\end_inset

 and in which round this vote was granted, 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Voted
\end_layout

\end_inset

.
 The 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

sorry
\end_layout

\end_inset

 message will simply send back the 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Round
\end_layout

\end_inset

 it cannot promise for.
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

{accept, Proposer, Round, Proposal}
\end_layout

\end_inset

 message sent by a 
\series bold
\emph on
Proposer
\series default
\emph default
 that had received a quorum of promises for the given 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Round
\end_layout

\end_inset

 and is now asking for votes for its proposed value 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Proposal
\end_layout

\end_inset

.
 The 
\series bold
\emph on
Acceptor
\series default
\emph default
 may answer with a 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

vote
\end_layout

\end_inset

 message if the current promise allows it to do so (i.e.
 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Round
\end_layout

\end_inset

 is greater than or equal to the current 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Promise
\end_layout

\end_inset

), or simply with 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

sorry
\end_layout

\end_inset

 message otherwise.
 The 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Voted
\end_layout

\end_inset

 variable learns the highest sequence number voted so far and 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Accepted
\end_layout

\end_inset

 learns the corresponding value for that vote.
 These values change in case the sequence number 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Round
\end_layout

\end_inset

 of this message is greater than 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Voted
\end_layout

\end_inset

, when 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Round
\end_layout

\end_inset

 replaces 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Voted
\end_layout

\end_inset

 and 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Proposal
\end_layout

\end_inset

 replaces 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Accepted
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

stop
\end_layout

\end_inset

 message sent by the 
\emph on
paxy
\emph default
 module asking the 
\series bold
\emph on
Acceptor
\series default
\emph default
 to finish its execution.
\end_layout

\begin_layout Standard
Finally the code of the 
\emph on
acceptor.erl
\emph default
 module for this basic part is like the following:
\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},language=erlang"
inline false
status open

\begin_layout Plain Layout

-module(acceptor).
\end_layout

\begin_layout Plain Layout

-export([start/3]).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-ifdef(debug).
\end_layout

\begin_layout Plain Layout

-define(DBG(X,Y,Z), io:format("[Accp_DEBUG] ~w: ~s ~w~n", [X, Y, Z])).
\end_layout

\begin_layout Plain Layout

-else.
 -define(DBG(X,Y,Z), true).
\end_layout

\begin_layout Plain Layout

-endif.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

start(Name, Seed, PanelId) ->
\end_layout

\begin_layout Plain Layout

    spawn(fun() -> init(Name, Seed, PanelId) end).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

init(Name, Seed, PanelId) ->
\end_layout

\begin_layout Plain Layout

    ?DBG(Name,"Acceptor Starting! PID:",self()),
\end_layout

\begin_layout Plain Layout

    random:seed(Seed, Seed, Seed),
\end_layout

\begin_layout Plain Layout

    Promise = order:null(),
\end_layout

\begin_layout Plain Layout

    Voted = order:null(),
\end_layout

\begin_layout Plain Layout

    Accepted = na,
\end_layout

\begin_layout Plain Layout

    acceptor(Name, Promise, Voted, Accepted, PanelId).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

acceptor(Name, Promise, Voted, Accepted, PanelId) ->
\end_layout

\begin_layout Plain Layout

    receive
\end_layout

\begin_layout Plain Layout

        {prepare, Proposer, Round} ->
\end_layout

\begin_layout Plain Layout

            ?DBG(Name,"Received a prepare from Proposer",Proposer),
\end_layout

\begin_layout Plain Layout

            ?DBG(Name,"And in the Round",Round),
\end_layout

\begin_layout Plain Layout

            ?DBG(Name,"I made the following promise so far:",Promise),
\end_layout

\begin_layout Plain Layout

            case order:gr(Round, Promise) of
\end_layout

\begin_layout Plain Layout

                true ->
\end_layout

\begin_layout Plain Layout

                    Proposer ! {promise, Round, Voted, Accepted},
\end_layout

\begin_layout Plain Layout

                    % Update gui
\end_layout

\begin_layout Plain Layout

                    if
\end_layout

\begin_layout Plain Layout

                        Accepted == na ->
\end_layout

\begin_layout Plain Layout

                            io:format("[Acceptor ~w]
\end_layout

\begin_layout Plain Layout

                                       set gui: voted ~w promise ~w colour
 na~n",
\end_layout

\begin_layout Plain Layout

                                      [Name, Voted, Round]),
\end_layout

\begin_layout Plain Layout

                            PanelId ! {updateAcc, "Round voted: "
\end_layout

\begin_layout Plain Layout

                                      ++ lists:flatten(io_lib:format("~p",
 [Voted])),
\end_layout

\begin_layout Plain Layout

                                                       "Cur.
 Promise: "
\end_layout

\begin_layout Plain Layout

                                      ++ lists:flatten(io_lib:format("~p",
 [Round])),
\end_layout

\begin_layout Plain Layout

                                                       {0,0,0}};
\end_layout

\begin_layout Plain Layout

                        true ->
\end_layout

\begin_layout Plain Layout

                            io:format("[Acceptor ~w]
\end_layout

\begin_layout Plain Layout

                                       set gui: voted ~w promise ~w colour
 ~w~n",
\end_layout

\begin_layout Plain Layout

                                      [Name, Voted, Round, Accepted]),
\end_layout

\begin_layout Plain Layout

                            PanelId ! {updateAcc, "Round voted: "
\end_layout

\begin_layout Plain Layout

            stop                           ++ lists:flatten(io_lib:format("~p",
 [Voted])),
\end_layout

\begin_layout Plain Layout

                                                        "Cur.
 Promise: "
\end_layout

\begin_layout Plain Layout

                                       ++ lists:flatten(io_lib:format("~p",
 [Round])),
\end_layout

\begin_layout Plain Layout

                                                        Accepted}
\end_layout

\begin_layout Plain Layout

                    end,
\end_layout

\begin_layout Plain Layout

                    acceptor(Name, Round, Voted, Accepted, PanelId);
\end_layout

\begin_layout Plain Layout

                false ->
\end_layout

\begin_layout Plain Layout

                    Proposer ! {sorry, Round},
\end_layout

\begin_layout Plain Layout

                    acceptor(Name, Promise, Voted, Accepted, PanelId)
\end_layout

\begin_layout Plain Layout

            end;
\end_layout

\begin_layout Plain Layout

        {accept, Proposer, Round, Proposal} ->
\end_layout

\begin_layout Plain Layout

            ?DBG(Name,"Received an accept message from",Proposer),
\end_layout

\begin_layout Plain Layout

            ?DBG(Name,"For voting in the round",Round),
\end_layout

\begin_layout Plain Layout

            ?DBG(Name,"For voting in the value",Proposal),
\end_layout

\begin_layout Plain Layout

            ?DBG(Name,"My promise so far is",Promise),
\end_layout

\begin_layout Plain Layout

            ?DBG(Name,"The highest ballot I voted for is",Voted),
\end_layout

\begin_layout Plain Layout

            case order:goe(Round, Promise) of
\end_layout

\begin_layout Plain Layout

                true ->
\end_layout

\begin_layout Plain Layout

                    Proposer ! {vote, Round},
\end_layout

\begin_layout Plain Layout

                    case order:goe(Round, Voted) of
\end_layout

\begin_layout Plain Layout

                        true ->
\end_layout

\begin_layout Plain Layout

                            % Update gui
\end_layout

\begin_layout Plain Layout

                            io:format("[Acceptor ~w]
\end_layout

\begin_layout Plain Layout

                                       set gui: voted ~w promise ~w colour
 ~w~n",
\end_layout

\begin_layout Plain Layout

                                      [Name, Round, Promise, Proposal]),
\end_layout

\begin_layout Plain Layout

                            PanelId ! {updateAcc, "Round voted: "
\end_layout

\begin_layout Plain Layout

                                       ++ lists:flatten(io_lib:format("~p",
 [Round])),
\end_layout

\begin_layout Plain Layout

                                                        "Cur.
 Promise: "
\end_layout

\begin_layout Plain Layout

                                       ++ lists:flatten(io_lib:format("~p",
 [Promise])),
\end_layout

\begin_layout Plain Layout

                                                        Proposal},
\end_layout

\begin_layout Plain Layout

                            acceptor(Name, Promise, Round, Proposal, PanelId);
\end_layout

\begin_layout Plain Layout

                        false ->
\end_layout

\begin_layout Plain Layout

                            % Update gui
\end_layout

\begin_layout Plain Layout

                            io:format("[Acceptor ~w]
\end_layout

\begin_layout Plain Layout

                                       set gui: voted ~w promise ~w colour
 ~w~n",
\end_layout

\begin_layout Plain Layout

                                      [Name, Round, Promise, Accepted]),
\end_layout

\begin_layout Plain Layout

                            PanelId ! {updateAcc, "Round voted: "
\end_layout

\begin_layout Plain Layout

                                       ++ lists:flatten(io_lib:format("~p",
 [Round])),
\end_layout

\begin_layout Plain Layout

                                                        "Cur.
 Promise: "
\end_layout

\begin_layout Plain Layout

                                       ++ lists:flatten(io_lib:format("~p",
 [Promise])),
\end_layout

\begin_layout Plain Layout

                                                        Accepted},
\end_layout

\begin_layout Plain Layout

                            acceptor(Name, Promise, Voted, Accepted, PanelId)
\end_layout

\begin_layout Plain Layout

                    end;
\end_layout

\begin_layout Plain Layout

                false ->
\end_layout

\begin_layout Plain Layout

                    Proposer ! {sorry, Round},
\end_layout

\begin_layout Plain Layout

                    acceptor(Name, Promise, Voted, Accepted, PanelId)
\end_layout

\begin_layout Plain Layout

            end;
\end_layout

\begin_layout Plain Layout

        stop ->
\end_layout

\begin_layout Plain Layout

            ok
\end_layout

\begin_layout Plain Layout

    end.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As will be described later in this document, this implementation works fine
 if none of the 
\series bold
\emph on
Acceptors
\series default
\emph default
 fail.
 In this case they'll simply recover without 
\emph on
memories
\emph default
 of previous promises and votes.
\end_layout

\begin_layout Subsubsection
proposer.erl
\end_layout

\begin_layout Standard
This module implements the 
\series bold
\emph on
Proposers
\series default
\emph default
 actions.
 The 
\emph on
paxy
\emph default
 module starts multiple of these elements with a predefined value that each
 one will try to make the system reach consensus upon.
 This value is stored during most of the execution in the variable 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Proposal
\end_layout

\end_inset

, which in our case is simply the color of the frames inside the 
\emph on
gui
\emph default
 window.
 All the proposers start at round 0, but to make each sequence number unique,
 the 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Round
\end_layout

\end_inset

 is set to be a tuple with the current sequence number and the name of the
 
\series bold
\emph on
Proposer
\series default
\emph default
 (that should be unique for each individual).
 As said before, this 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Round
\end_layout

\end_inset

 is going to be used by the 
\series bold
\emph on
Acceptors
\series default
\emph default
 for comparing the promises with the new propositions, and this tuple in
 our system will lead to an interesting result that will be discussed later.
\end_layout

\begin_layout Standard
So after these initializations, a 
\series bold
\emph on
Proposer
\series default
\emph default
 will start the first round and enter the 
\emph on
ballot
\emph default
 state for that round.
 There it will request all the existing 
\series bold
\emph on
Acceptors
\series default
\emph default
 to perform the 
\emph on
prepare
\emph default
 action for that given 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Round
\end_layout

\end_inset

 and will collect the 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

promise
\end_layout

\end_inset

 and 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

sorry
\end_layout

\end_inset

 messages that will arrive back.
 Actually the 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

sorry
\end_layout

\end_inset

 messages are just discarded and therefore what it's really interested is
 the promises.
 It will count the number of 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

promise
\end_layout

\end_inset

 messages until it receives a 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Quorum
\end_layout

\end_inset

 number of them, where 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Quorum
\end_layout

\end_inset

 is the total number of 
\series bold
\emph on
Acceptors
\series default
\emph default
 divided by two, plus one (majority).
 So the messages expected when collecting promises will be:
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

{promise, Round, Voted, Value}
\end_layout

\end_inset

 message, where an 
\series bold
\emph on
Acceptor
\series default
\emph default
 is promising not to vote in any value with a sequence number lower than
 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Round
\end_layout

\end_inset

.
 As already mentioned, if that 
\series bold
\emph on
Acceptor
\series default
\emph default
 had already voted for a value, 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Value
\end_layout

\end_inset

 and 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Voted
\end_layout

\end_inset

 will be the value it voted for and in which round it did it.
 If this already voted value had a sequence number higher than the requested
 new promise, the 
\series bold
\emph on
Proposer
\series default
\emph default
 will then learn that 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Value
\end_layout

\end_inset

 Votedas its new 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Proposal
\end_layout

\end_inset

.
 From this point the system will be on it's way to reach consensus because
 with this new value the 
\series bold
\emph on
Proposer
\series default
\emph default
 will confirm with the 
\series bold
\emph on
Acceptors
\series default
\emph default
 that it should agree on that value.
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

{sorry, Round}
\end_layout

\end_inset

 messages, where an 
\series bold
\emph on
Acceptor
\series default
\emph default
 is saying it can't promise that sequence number, which obviously means
 that it already made a promise for a higher number, but the 
\series bold
\emph on
Proposer
\series default
\emph default
 won't know what number is that.
\end_layout

\begin_layout Standard
If a 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Quorum
\end_layout

\end_inset

 number of 
\series bold
\emph on
Acceptors
\series default
\emph default
 send promises for a certain 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Round
\end_layout

\end_inset

 that proposal is accepted and therefore it can continue with that sequence
 number or if it timeouts waiting for promises that round is aborted and
 a new one is started.
 When starting a new round the 
\series bold
\emph on
Proposer
\series default
\emph default
 will sleep for a certain amount of time that increases withing the execution
 and then increases the sequence number of the 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Round
\end_layout

\end_inset

 for a new try.
\end_layout

\begin_layout Standard
If the promise collection succeeds, the 
\series bold
\emph on
Proposer
\series default
\emph default
 will issue to all the 
\series bold
\emph on
Acceptors
\series default
\emph default
 to perform an 
\emph on
accept
\emph default
 action and will collect the votes from them.
 As already mentioned, the 
\series bold
\emph on
Acceptors
\series default
\emph default
 may answer with two different messages:
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

{vote, Round}
\end_layout

\end_inset

 message that the 
\series bold
\emph on
Proposer
\series default
\emph default
 will use to count the number of votes until it receives a 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Quorum
\end_layout

\end_inset

 number of them, when it realizes the 
\series bold
\emph on
Acceptors
\series default
\emph default
 reached a consensus about that value it just proposed.
\end_layout

\begin_layout Itemize
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

{sorry, Round}
\end_layout

\end_inset

 message that in this implementation is simply discarded, but on the optimized
 version of the code will be counted so that after receiving a 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Quorum
\end_layout

\end_inset

 number of 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

sorry
\end_layout

\end_inset

 messages, the 
\series bold
\emph on
Proposer
\series default
\emph default
 knows that it can start a new round because it will never reach consensus
 on the current one.
\end_layout

\begin_layout Standard
While waiting for these messages the 
\series bold
\emph on
Proposer
\series default
\emph default
 may timeout and that will lead it to a new round.
 Finally the code of the 
\emph on
proposer.erl
\emph default
 module for this basic part is like the following:
\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},language=erlang"
inline false
status open

\begin_layout Plain Layout

-module(proposer).
\end_layout

\begin_layout Plain Layout

-export([start/5]).
\end_layout

\begin_layout Plain Layout

-define(timeout, 2000).
\end_layout

\begin_layout Plain Layout

-define(backoff, 10).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

-ifdef(debug).
\end_layout

\begin_layout Plain Layout

-define(DBG(X,Y,Z),io:format("[Prop_DEBUG] ~w: ~s ~w~n", [X, Y, Z])).
\end_layout

\begin_layout Plain Layout

-else.
\end_layout

\begin_layout Plain Layout

-define(DBG(X,Y,Z), true).
\end_layout

\begin_layout Plain Layout

-endif.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

start(Name, Proposal, Acceptors, Seed, PanelId) ->
\end_layout

\begin_layout Plain Layout

    spawn(fun() -> init(Name, Proposal, Acceptors, Seed, PanelId) end).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

init(Name, Proposal, Acceptors, Seed, PanelId) ->
\end_layout

\begin_layout Plain Layout

    ?DBG(Name,"Proposer starting! PID:",self()),
\end_layout

\begin_layout Plain Layout

    random:seed(Seed, Seed, Seed),
\end_layout

\begin_layout Plain Layout

    Round = order:null(Name),
\end_layout

\begin_layout Plain Layout

    round(Name, ?backoff, Round, Proposal, Acceptors, PanelId).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

round(Name, Backoff, Round, Proposal, Acceptors, PanelId) ->
\end_layout

\begin_layout Plain Layout

    % Update gui
\end_layout

\begin_layout Plain Layout

    io:format("[Proposer ~w | round()] set gui: Round ~w Proposal ~w~n",
\end_layout

\begin_layout Plain Layout

              [Name, Round, Proposal]),
\end_layout

\begin_layout Plain Layout

    PanelId ! {updateProp, "Round: "
\end_layout

\begin_layout Plain Layout

               ++ lists:flatten(io_lib:format("~p", [Round])), "Proposal:
 "
\end_layout

\begin_layout Plain Layout

               ++ lists:flatten(io_lib:format("~p", [Proposal])), Proposal},
\end_layout

\begin_layout Plain Layout

   case ballot(Name, Round, Proposal, Acceptors, PanelId) of
\end_layout

\begin_layout Plain Layout

        {ok, Decision} ->
\end_layout

\begin_layout Plain Layout

            io:format("[Proposer ~w] ~w decided ~w in round ~w~n",
\end_layout

\begin_layout Plain Layout

       color               [Name, Acceptors, Decision, Round]),
\end_layout

\begin_layout Plain Layout

            {ok, Decision};
\end_layout

\begin_layout Plain Layout

        abort ->
\end_layout

\begin_layout Plain Layout

            ?DBG(Name,"Aborted this round, let's try again! Failed round:",Round
),
\end_layout

\begin_layout Plain Layout

            timer:sleep(random:uniform(Backoff)),
\end_layout

\begin_layout Plain Layout

            Next = order:inc(Round),
\end_layout

\begin_layout Plain Layout

            round(Name, (2*Backoff), Next, Proposal, Acceptors, PanelId)
\end_layout

\begin_layout Plain Layout

    end.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

ballot(Name, Round, Proposal, Acceptors, PanelId) ->
\end_layout

\begin_layout Plain Layout

    prepare(Round, Acceptors),
\end_layout

\begin_layout Plain Layout

    Quorum = (length(Acceptors) div 2) + 1,
\end_layout

\begin_layout Plain Layout

    ?DBG(Name,"Quorum value is:",Quorum),
\end_layout

\begin_layout Plain Layout

    Max = order:null(),
\end_layout

\begin_layout Plain Layout

    case collect(Name, Quorum, Round, Max, Proposal) of
\end_layout

\begin_layout Plain Layout

        {accepted, Value} ->
\end_layout

\begin_layout Plain Layout

            % update gui
\end_layout

\begin_layout Plain Layout

            io:format("[Proposer ~w | ballot()] set gui: Round ~w Proposal
 ~w~n",
\end_layout

\begin_layout Plain Layout

                      [Name, Round, Value]),
\end_layout

\begin_layout Plain Layout

            PanelId ! {updateProp, "Round: "
\end_layout

\begin_layout Plain Layout

                       ++ lists:flatten(io_lib:format("~p", [Round])),
\end_layout

\begin_layout Plain Layout

                       "Proposal: "
\end_layout

\begin_layout Plain Layout

                       ++ lists:flatten(io_lib:format("~p", [Value])),
\end_layout

\begin_layout Plain Layout

                       Value},
\end_layout

\begin_layout Plain Layout

            accept(Round, Value, Acceptors),
\end_layout

\begin_layout Plain Layout

            case vote(Name, Quorum, Round) of
\end_layout

\begin_layout Plain Layout

                ok ->
\end_layout

\begin_layout Plain Layout

                    {ok, Value};
\end_layout

\begin_layout Plain Layout

                abort ->
\end_layout

\begin_layout Plain Layout

                    abort
\end_layout

\begin_layout Plain Layout

            end;
\end_layout

\begin_layout Plain Layout

        abort -> 
\end_layout

\begin_layout Plain Layout

           abort
\end_layout

\begin_layout Plain Layout

    end.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

collect(_, 0, _, _, Proposal) ->
\end_layout

\begin_layout Plain Layout

    {accepted, Proposal};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

collect(Name, N, Round, Max, Proposal) ->
\end_layout

\begin_layout Plain Layout

    ?DBG(Name,"promises missing:",N),
\end_layout

\begin_layout Plain Layout

    receive
\end_layout

\begin_layout Plain Layout

        {promise, Round, _, na} ->Note
\end_layout

\begin_layout Plain Layout

            ?DBG(Name,"Received a promise for Round",Round),
\end_layout

\begin_layout Plain Layout

            collect(Name, N-1, Round, Max, Proposal);
\end_layout

\begin_layout Plain Layout

        {promise, Round, Voted, Value} ->
\end_layout

\begin_layout Plain Layout

            ?DBG(Name,"Received a promise for Round",Round),
\end_layout

\begin_layout Plain Layout

       color     case order:gr(Voted, Max) of
\end_layout

\begin_layout Plain Layout

                true ->
\end_layout

\begin_layout Plain Layout

                    ?DBG(Name,"New sequence number is",Voted),
\end_layout

\begin_layout Plain Layout

                    ?DBG(Name,"New value is",Value),
\end_layout

\begin_layout Plain Layout

                    collect(Name, N-1, Round, Voted, Value);
\end_layout

\begin_layout Plain Layout

                false ->
\end_layout

\begin_layout Plain Layout

                    collect(Name, N-1, Round, Max, Proposal)
\end_layout

\begin_layout Plain Layout

            end;
\end_layout

\begin_layout Plain Layout

        {promise, _, _, _} ->
\end_layout

\begin_layout Plain Layout

            collect(Name, N, Round, Max, Proposal);
\end_layout

\begin_layout Plain Layout

        {sorry, Round} ->
\end_layout

\begin_layout Plain Layout

            ?DBG(Name,"Received a sorry for Round", Round),
\end_layout

\begin_layout Plain Layout

            collect(Name, N, Round, Max, Proposal);
\end_layout

\begin_layout Plain Layout

        {sorry, _} ->
\end_layout

\begin_layout Plain Layout

            collect(Name, N, Round, Max, Proposal)
\end_layout

\begin_layout Plain Layout

    after ?timeout ->
\end_layout

\begin_layout Plain Layout

            abort
\end_layout

\begin_layout Plain Layout

    end.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

vote(_, 0, _) ->
\end_layout

\begin_layout Plain Layout

    ok;
\end_layout

\begin_layout Plain Layout

vote(Name, N, Round) ->
\end_layout

\begin_layout Plain Layout

    ?DBG(Name,"Votes missing:",N),
\end_layout

\begin_layout Plain Layout

    receive
\end_layout

\begin_layout Plain Layout

        {vote, Round} ->
\end_layout

\begin_layout Plain Layout

            ?DBG(Name,"Received one more vote for Round",Round),
\end_layout

\begin_layout Plain Layout

            vote(Name, N-1, Round);
\end_layout

\begin_layout Plain Layout

        {vote, _} ->
\end_layout

\begin_layout Plain Layout

            vote(Name, N, Round);
\end_layout

\begin_layout Plain Layout

        {sorry, Round} ->
\end_layout

\begin_layout Plain Layout

            ?DBG(Name,"Received one more sorry for Round",Round),
\end_layout

\begin_layout Plain Layout

            vote(Name, N, Round);
\end_layout

\begin_layout Plain Layout

        {sorry, _} ->
\end_layout

\begin_layout Plain Layout

            vote(Name, N, Round)
\end_layout

\begin_layout Plain Layout

    after ?timeout ->
\end_layout

\begin_layout Plain Layout

            abort
\end_layout

\begin_layout Plain Layout

    end.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

prepare(Round, Acceptors) ->
\end_layout

\begin_layout Plain Layout

    Fun = fun(Acceptor) ->
\end_layout

\begin_layout Plain Layout

                  send(Acceptor, {prepare, self(), Round})
\end_layout

\begin_layout Plain Layout

          end,
\end_layout

\begin_layout Plain Layout

    lists:map(Fun, Acceptors).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

accept(Round, Proposal, Acceptors) ->
\end_layout

\begin_layout Plain Layout

    Fun = fun(Acceptor) ->
\end_layout

\begin_layout Plain Layout

                  send(Acceptor, {accept, self(), Round, Proposal})
\end_layout

\begin_layout Plain Layout

          end,
\end_layout

\begin_layout Plain Layout

    lists:map(Fun, Acceptors).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

send(Name, Message) ->
\end_layout

\begin_layout Plain Layout

    Name ! Message.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This code will also be discussed later on, but it works as expected.
\end_layout

\begin_layout Subsection
Fault-tolerant
\end_layout

\begin_layout Standard

\series bold
\bar under
Note
\series default
\bar default
: the source code for this part is in the 
\emph on
src_fault_tolerant/
\emph default
 folder.
\end_layout

\begin_layout Standard
The Paxos algorithm to be reliable must be implemented with fault-tolerant
 
\series bold
\emph on
Acceptors
\series default
\emph default
, so that when they fail for whatever reason they may be able to return
 back and recover the previous promises and votes it did.
 For that we made use of the 
\emph on
pers.erl
\emph default
 module proposed by 
\begin_inset CommandInset citation
LatexCommand cite
key "emdc_sodx4"

\end_inset

.
 Using simple 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

read()
\end_layout

\end_inset

, 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

store()
\end_layout

\end_inset

 and 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

delete()
\end_layout

\end_inset

 exported functions it manages data in persistent memory (by keeping a individua
l file in the hard disk per process).
\end_layout

\begin_layout Standard
The 
\emph on
acceptors.erl
\emph default
 module is changed to use these exported functions by first reading what
 should be the initial state of that 
\series bold
\emph on
Acceptor
\series default
\emph default
, and later on by writing its new current state for every action performed
 that changes any of the stored variables, in this case 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Promise
\end_layout

\end_inset

, 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Voted
\end_layout

\end_inset

 and 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Accepted
\end_layout

\end_inset

.
 The 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Name
\end_layout

\end_inset

 and the 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

PanelId
\end_layout

\end_inset

 are also stored for later use when recovering.
 Finally, when exiting the execution after receiving a 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

stop
\end_layout

\end_inset

 message from 
\emph on
paxy
\emph default
 the file is properly closed.
\end_layout

\begin_layout Standard
Further discussion and explanations will be made in the next section but
 the final code made for this part is making use of some 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

timer:sleep()
\end_layout

\end_inset

 so that we can see a more real world environment execution of the algorithm.
 Basically without it, the voting ends quickly after just a very few rounds
 and always with the same value agreed upon.
\end_layout

\begin_layout Standard
Finally the changes in the code of the 
\emph on
acceptor.erl
\emph default
 module for this fault-tolerant part is like the following:
\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},language=erlang"
inline false
status open

\begin_layout Plain Layout

\size footnotesize
(...)
\end_layout

\begin_layout Plain Layout

\size footnotesize
init(Name, Seed, na) ->
\end_layout

\begin_layout Plain Layout

\size footnotesize
    ?DBG(Name,"Recovering from crash! PID:",self()),
\end_layout

\begin_layout Plain Layout

\size footnotesize
    random:seed(Seed, Seed, Seed),
\end_layout

\begin_layout Plain Layout

\size footnotesize
    {Promise, Voted, Accepted, PanelId} = pers:read(Name),
\end_layout

\begin_layout Plain Layout

\size footnotesize
    acceptor(Name, Promise, Voted, Accepted, PanelId);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size footnotesize
init(Name, Seed, PanelId) ->
\end_layout

\begin_layout Plain Layout

\size footnotesize
   ?DBG(Name,"Acceptor Starting! PID:",self()),
\end_layout

\begin_layout Plain Layout

\size footnotesize
    random:seed(Seed, Seed, Seed),
\end_layout

\begin_layout Plain Layout

\size footnotesize
    {Promise, Voted, Accepted, _PanelId} = pers:read(Name),
\end_layout

\begin_layout Plain Layout

\size footnotesize
    acceptor(Name, Promise, Voted, Accepted, PanelId).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\size footnotesize
acceptor(Name, Promise, Voted, Accepted, PanelId) ->
\end_layout

\begin_layout Plain Layout

\size footnotesize
    receive
\end_layout

\begin_layout Plain Layout

\size footnotesize
        {prepare, Proposer, Round} ->
\end_layout

\begin_layout Plain Layout

\size footnotesize
        (...)
\end_layout

\begin_layout Plain Layout

\size footnotesize
            case order:gr(Round, Promise) of
\end_layout

\begin_layout Plain Layout

\size footnotesize
                true ->
\end_layout

\begin_layout Plain Layout

\size footnotesize
                    pers:store(Name, Round, Voted, Accepted, PanelId),
\end_layout

\begin_layout Plain Layout

\size footnotesize
        (...)
\end_layout

\begin_layout Plain Layout

\size footnotesize
        {accept, Proposer, Round, Proposal} ->
\end_layout

\begin_layout Plain Layout

\size footnotesize
            case order:goe(Round, Promise) of
\end_layout

\begin_layout Plain Layout

\size footnotesize
                true ->
\end_layout

\begin_layout Plain Layout

\size footnotesize
                    R = random:uniform(?delay),
\end_layout

\begin_layout Plain Layout

\size footnotesize
                    timer:sleep(R),
\end_layout

\begin_layout Plain Layout

\size footnotesize
                    Proposer ! {vote, Round},
\end_layout

\begin_layout Plain Layout

\size footnotesize
                    case order:goe(Round, Voted) of
\end_layout

\begin_layout Plain Layout

\size footnotesize
                        true ->
\end_layout

\begin_layout Plain Layout

\size footnotesize
                            pers:store(Name, Promise, Round, Proposal, PanelId),
\end_layout

\begin_layout Plain Layout

\size footnotesize
                    (...)
\end_layout

\begin_layout Plain Layout

\size footnotesize
        stop ->
\end_layout

\begin_layout Plain Layout

\size footnotesize
            pers:delete(Name),
\end_layout

\begin_layout Plain Layout

\size footnotesize
            ok
\end_layout

\begin_layout Plain Layout

\size footnotesize
    end.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To force a single 
\series bold
\emph on
Acceptor
\series default
\emph default
 to crash and recover immediately we make use of the 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

crash()
\end_layout

\end_inset

 function proposed by 
\begin_inset CommandInset citation
LatexCommand cite
key "emdc_sodx4"

\end_inset

 to be added to the 
\emph on
paxy
\emph default
 module.
 With all this set, the system works fine even after an 
\series bold
\emph on
Acceptor
\series default
\emph default
 node crashes and recovers with all the promises it made so far.
\end_layout

\begin_layout Standard
The 
\emph on
proposer.erl
\emph default
 module was changed as well to verify is the acceptor that it's trying to
 send a message is still alive or not.
 The code for this was proposed by 
\begin_inset CommandInset citation
LatexCommand cite
key "emdc_sodx4"

\end_inset

.
\end_layout

\begin_layout Subsection
Optimized
\end_layout

\begin_layout Standard

\series bold
\bar under
Note
\series default
\bar default
: the source code for this part is in the 
\emph on
src_fault_tolerant_optimized/
\emph default
 folder.
\end_layout

\begin_layout Standard
This final version adds a possible optimization to the system where a 
\series bold
\emph on
Proposer
\series default
\emph default
 may now start a new round after receiving 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Quorum
\end_layout

\end_inset

 number of 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

sorry
\end_layout

\end_inset

 messages when either collecting promises or votes from the 
\series bold
\emph on
Acceptors
\series default
\emph default
.
 For this we simply pass the 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

Quorum
\end_layout

\end_inset

 value also to be used to count these messages, and immediately return 
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=erlang"
inline true
status open

\begin_layout Plain Layout

abort
\end_layout

\end_inset

 to start the next round.
\end_layout

\begin_layout Standard
The changes made on the code of the 
\emph on
proposer.erl
\emph default
 module were the following:
\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},language=erlang"
inline false
status open

\begin_layout Plain Layout

(...)
\end_layout

\begin_layout Plain Layout

collect(_, 0, _, _, _, Proposal) ->
\end_layout

\begin_layout Plain Layout

    {accepted, Proposal};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

collect(Name, _, 0, Round, _, _) ->
\end_layout

\begin_layout Plain Layout

    ?DBG(Name,"---[Optimization] Aborting collect on Round",Round),
\end_layout

\begin_layout Plain Layout

    abort;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

collect(Name, N, AbortN, Round, Max, Proposal) ->
\end_layout

\begin_layout Plain Layout

    ?DBG(Name,"promises missing:",N),
\end_layout

\begin_layout Plain Layout

    receive
\end_layout

\begin_layout Plain Layout

        (...)
\end_layout

\begin_layout Plain Layout

        {sorry, Round} ->
\end_layout

\begin_layout Plain Layout

            ?DBG(Name,"Received a sorry for Round", Round),
\end_layout

\begin_layout Plain Layout

            collect(Name, N, AbortN-1, Round, Max, Proposal);
\end_layout

\begin_layout Plain Layout

        {sorry, _} ->
\end_layout

\begin_layout Plain Layout

            collect(Name, N, AbortN, Round, Max, Proposal)
\end_layout

\begin_layout Plain Layout

    after ?timeout ->
\end_layout

\begin_layout Plain Layout

            abort
\end_layout

\begin_layout Plain Layout

    end.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

vote(_, 0, _, _) ->
\end_layout

\begin_layout Plain Layout

    ok;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

vote(Name, _, 0, Round) ->
\end_layout

\begin_layout Plain Layout

    ?DBG(Name,"---[Optimization] Abort voting on Round",Round),
\end_layout

\begin_layout Plain Layout

    abort;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

vote(Name, N, AbortN, Round) ->
\end_layout

\begin_layout Plain Layout

    receive
\end_layout

\begin_layout Plain Layout

        (...)
\end_layout

\begin_layout Plain Layout

        {sorry, Round} ->
\end_layout

\begin_layout Plain Layout

            ?DBG(Name,"Received one more sorry for Round",Round),
\end_layout

\begin_layout Plain Layout

            vote(Name, N, AbortN-1, Round);
\end_layout

\begin_layout Plain Layout

        {sorry, _} ->
\end_layout

\begin_layout Plain Layout

            vote(Name, N, AbortN, Round)
\end_layout

\begin_layout Plain Layout

    after ?timeout ->
\end_layout

\begin_layout Plain Layout

            abort
\end_layout

\begin_layout Plain Layout

    end.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
These changes performed well on the system and still the nodes are able
 to reach consensus.
\end_layout

\begin_layout Section
Evaluation
\end_layout

\begin_layout Subsection
Basic
\end_layout

\begin_layout Standard
The basic implementation runs
\end_layout

\begin_layout Subsection
Fault-tolerant
\end_layout

\begin_layout Standard
asd
\end_layout

\begin_layout Subsection
Optimized
\end_layout

\begin_layout Standard
asd
\end_layout

\begin_layout Section
Open questions
\end_layout

\begin_layout Itemize

\emph on
Do some experiments and see how the system works.
 Split the paxy module in two parts and make the needed adaptations to enable
 the acceptors (with the gui) and the proposers to run in different machines.
\end_layout

\begin_layout Standard
asd
\end_layout

\begin_layout Itemize

\emph on
Try to introduce delays in the acceptor and the proposer.
 Insert larger delays and see if the algorithm still terminates.
\end_layout

\begin_layout Standard
asd
\end_layout

\begin_layout Itemize

\emph on
Could you even come to an agreement when you ignore messages?
\end_layout

\begin_layout Itemize

\emph on
Does the algorithm ever report conflicting answers?
\end_layout

\begin_layout Standard
asd
\end_layout

\begin_layout Itemize

\emph on
What happens if we increase the number of acceptors to say 9 or 17? Will
 we reach a decision? What if we have also have 10 proposers?
\end_layout

\begin_layout Standard
asd
\end_layout

\begin_layout Itemize
Simulate a crash using the crash thing.
\end_layout

\begin_layout Standard
asd
\end_layout

\begin_layout Section
Conclusions
\end_layout

\begin_layout Standard
asd
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "sodx"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
